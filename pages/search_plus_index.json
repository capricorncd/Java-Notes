{"./":{"url":"./","title":"Introduction","keywords":"","body":"Java 教程笔记 Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。 文档：https://capricorncd.github.io/Java-Notes/ [!TIP|style:flat|label:注意] 文档中类或接口类方法截图为 JavaSE-1.8 版本 构建文档 # 开发模式 npm run dev # 生成文档 npm run build 目录 Java基础第一季 Java发展历程、Java平台应用、JVM/JDK/JRE、开发环境搭建 变量与常量 运算符 流程控制语句 数组 方法 Java基础第二季 类和对象 封装 继承 多态 Java中的抽象类 接口Interface UML Java基础第三季 异常与异常处理 异常抛出及自定义异常 Java 中的字符串 thread-safe 线程安全 包装类 Date和SimpleDateFormat类 Calendar类的应用 Math类 集合框架Collection、Map 泛型 Set接口，及其实现类HashSet Map & HashMap Collections工具类 ... 文档：https://capricorncd.github.io/Java-Notes/ © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/first-season/java.html":{"url":"pages/first-season/java.html","title":"Java","keywords":"","body":"Java Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。 Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。 Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。 Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 Java发展历程 1995由Sun公司推出，2009被Oracle收购。 Java平台应用 核心概念：JVM/JDK/JRE [!TIP|label:JVM|style:flat] Java Virtual Machine [!TIP|label:JDK|style:flat] Java Development Kit (Java开发工具包) [!TIP|label:JRE|style:flat] Java Runtime Environment (Java运行时环境) Java 开发环境搭建 1、安装JDK https://www.oracle.com/technetwork/java/javase/downloads/index.html JDK8 https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html [!TIP|style:flat] Java库文件，以 .jar 结尾 bin目录文件： lib目录文件： 2、window 10 配置环境变量（系统变量） # 配置JDK安装路径 JAVA_HOME C:\\Program Files\\Java\\jdk1.8.0_172 # 配置类库文件的位置 CLASSPATH .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar # 配置JDK命令文件的位置 path C:\\ProgramFiles\\Java\\jdk1.8.0_172\\bin C:\\Program Files\\Java\\jdk1.8.0_172\\bin\\jre\\bin 测试配置是否成功： 3、Mac 直接装jdk-8u201-macosx-x64.dmg就可以了。 使用工具开发Java程序 HelloWorld.java public class HelloWorld { public static void main(String[] args) { System.out.println(\"Welcome to Java world.\"); } } 使用bash，找到文件路径，执行 javac HelloWorld.java 此时，会在当前位置生产一个HelloWorld.class的字节码文件。 # 执行字节码文件，注意不能跟后缀名.class java HelloWorld # Welcome to Java world. 使用IDE开发 集成开发环境（IDE）是一类软件 将程序开发环境和程序调试环境集合在一起，提高开发效率。 Eclipse 开源免费的。下载地址 https://www.eclipse.org/downloads/ MyEclipse MyEclipse是对Eclipse的扩展，是一个十分优秀的用于开发Java、JavaEE的Eclipse插件集合。 https://www.myeclipsecn.com 开发流程 以Eclipse为例 1 创建Java项目 file -> New -> Java Project # Project name: hello 2 创建程序包 # src 目录 New -> Package # com.hello 3 编写Java源程序 com.hello -> New -> Class > Name: HelloTest IDE自动生成：HelloTest.java package com.hello; public class HelloTest { } [!WARNING|style:flat|label:注意] 类名 class HelloTest 一定要与文件名 HelloTest.java 相同。 如下图： 4 运行Java程序 代码编辑拦，空白处鼠标右键 -> Run As -> Java Application ... 或者点击编辑器左上角的\"播放\"图标，run ... 程序的移植 从公司拷回屋里继续写... 拷贝项目代码 -> 到家，开电脑，打开软件 -> File -> Import -> General/Existing Project into Workspace -> Next -> Select root directory: [Broser] -> 找到文件 -> Finish 来自巨人的经验 多练、多问、自己动手，调试错误、复习和总结。 Java中泛型的本质 Java中静态变量的适用场景 Java类加载原理及类加载器 Java中对Clone的理解 Java中HashMap的实现 Java中Collection和Collections的区别 Java数组浅析 Java代码优化编程 Java事件处理机制与“恋爱关系” Java中的JNDI（Java命令与目录接口） Java中Comparable和Comparator实现对象比较 Java中String和StringBuffer的区别 Java中反射机制 Java中的synchronized 学虽容易，学好不易，且学且珍惜。 原教程出处 https://www.imooc.com/learn/85 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/first-season/variable-and-constant.html":{"url":"pages/first-season/variable-and-constant.html","title":"变量与常量","keywords":"","body":"变量与常量 Java关键字 Java 关键字是区分大小写 Java标识符 标识符就是用于给 Java 程序中变量、类、方法等命名的符号。 使用标识符时，需要遵守几条规则： 1、标识符可以由字母、数字、下划线（_）、美元符（$）组成，但不能包含 @、%、空格等其它特殊字符，不能以数字开头。譬如：123name 就是不合法。 2、标识符不能是 Java 关键字和保留字（ Java 预留的关键字，以后的升级版本中有可能作为关键字），但可以包含关键字和保留字。如：不可以使用 void 作为标识符，但是 Void 可以。 3、标识符是严格区分大小写的。 4、标识符的命名最好能反映出其作用，做到见名知意。 变量 在 Java 中，我们通过三个元素描述变量：变量类型、变量名以及变量值。 int a = 30; String b = \"this is String\"; 通常： 1、变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 createUserInfo。 2、变量命名时，尽量简短且能清楚的表达变量的作用，做到见名知意。如：定义变量名 studentName 保存“学生姓名”信息。 3、Java 变量名的长度没有限制，但 Java 语言是区分大小写的，所以price和Price 是两个完全不同的变量！ public class HelloWorld { public static void main(String[] args) { int hobby = 9999; System.out.println(hobby); } } Java中的数据类型 Java 语言是一种强类型语言。通俗点说就是，在 Java 中存储的数据都是有类型的，而且必须在编译时就确定其类型。 Java 中有两类数据类型： [!WARNING|style:flat|label:注意] 在Java里，基本数据类型 变量存的是 数据本身，而 引用类型 变量存的是保存数据的 空间地址。 数据类型 说明 字节 应用 示例 int 整型 4 整数，如年龄/个数等 int age=21; double 双精度浮点型 8 小数，如商品价格/成绩平均分等 double price=21.5; float 单精度浮点型 4 小数，如身高等 float height=180.3f; char 字符型 2 单个字符，如性别男/女 char gander='男'; boolean 布尔型 1 表示真true或假false boolean flag=true; [!TIP|style:flat] float变量赋值时，在数值后面添加字母 f。 char变量赋值时，使用单引号 '。 Java中变量的使用规则 Java 中的变量需要先声明后使用 变量使用时，可以声明变量的同时进行初始化 变量中每次只能赋一个值，但可以修改多次 main 方法中定义的变量必须先赋值，然后才能输出 String a; System.out.println(a); // error [!WARNING|style:flat|label:注意] 虽然语法中不会提示错误，但在实际开发中，变量名不建议使用中文，容易产生安全隐患。譬如后期跨平台操作时出现乱码等等。 Java中的自动类型转换 自动类型转换: int a = 89; double b = a; System.out.println(b); // 89.0 自动类型转换是需要满足特定的条件: 1、目标类型能与源类型兼容，如 double 型兼容 int 型，但是 char 型不能兼容 int 型。 2、目标类型大于源类型，如 double 类型长度为 8 字节， int 类型为 4 字节，因此 double 类型的变量里直接可以存放 int 类型的数据，但反过来就不可以。 Java中的强制类型转换 double average = 74.9; int average2 = (int)average; System.out.println(average); // 74.9 System.out.println(average2); // 74 [!WARNING|style:flat|label:注意] 强制类型转换可能会造成数据的丢失 Java常量的应用 语法 final 常量名 = 值; 程序中使用常量可以提高代码的可维护性。 常量名一般使用大写字符。 Java中使用注释 在编写程序时，经常需要添加一些注释，用以描述某段代码的作用。 一般来说，对于一份规范的程序源代码而言，注释应该占到源代码的 1/3 以上。因此，注释是程序源代码的重要组成部分。 Java 中注释有三种类型：单行注释、多行注释、文档注释。 package com.test /** * 这是文档注释 * @author authorName * @version v1.0.0 */ public class TestDemo { /* * 这是多行注释 * 可以包含多行内容 */ public static void main(String[] args) { // 这是单行注释 System.out.println(\"Hello World\"); } } 我们可以通过 javadoc 命令从文档注释中提取内容，生成程序的 API 帮助文档。 javadoc -d doc TestDemo.java 使用文档注释时还可以使用 javadoc 标记，生成更详细的文档信息： @author 标明开发该类模块的作者 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @param 对方法中某参数的说明 @return 对方法返回值的说明 @exception 对方法可能抛出的异常进行说明 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/first-season/operator.html":{"url":"pages/first-season/operator.html","title":"运算符","keywords":"","body":"运算符 算术运算符 赋值运算符 比较运算符 逻辑运算符 条件运算符 算术运算符 算术运算符主要用于进行基本的算术运算，如加法、减法、乘法、除法等。 赋值运算符 赋值运算符是指为变量或常量指定数值的符号。如可以使用 “=” 将右边的表达式结果赋给左边的操作数。 比较运算符 比较运算符用于判断两个数据的大小，例如：大于、等于、不等于。比较的结果是一个布尔值（ true 或 false ）。 1、>、、>=、 只支持左右两边操作数是数值类型 2、==、!= 两边的操作数既可以是数值类型，也可以是引用类型 逻辑运算符 逻辑运算符主要用于进行逻辑运算。Java 中常用的逻辑运算符如下表所示： 我们可以从“投票选举”的角度理解逻辑运算符： 1、与：要求所有人都投票同意，才能通过某议题 2、或：只要求一个人投票同意就可以通过某议题 3、非：某人原本投票同意，通过非运算符，可以使其投票无效 4、异或：有且只能有一个人投票同意，才可以通过某议题 当使用逻辑运算符时，我们会遇到一种很有趣的“短路”现象。 譬如：( one > two ) && ( one two 运行结果为 false , 则系统就认为已经没有必要执行右侧的 one 同理，在( one > two ) || ( one 条件运算符 条件运算符（ ? : ）也称为 “三元运算符”。 语法： 布尔表达式 ？表达式1 ：表达式2 运算符的优先级 所谓优先级，就是在表达式中的运算顺序。 优先级 运算符 1 () 2 ! +正 -负 ++ -- 3 * / % 4 +加 -减 5 >= 6 == != 7 ^ 8 && 9 10 ? :三元运算符 11 = += -= *= /= %= 级别为 1 的优先级最高，级别 11 的优先级最低。 ( 11+ 3* 8 ) / 4 % 3; // 2 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/first-season/flow-control-statement.html":{"url":"pages/first-season/flow-control-statement.html","title":"流程控制语句","keywords":"","body":"流程控制语句 if, if else if (BooleanConditionalExpression) { // do something } else { // do something } if (BooleanConditionalExpression1) { // do something } else if (BooleanConditionalExpression2) { // do something } else { // do something } switch switch (Expression) { case Value1: // do something break; case Value1: // do something break; default: // do something } while int i = 1; while (i for for (循环变量初始化; 循环条件; 循环变量变化) { // 循环操作 } 执行过程： 1、执行循环变量初始化部分，设置循环的初始状态，此部分在整个循环中只执行一次 2、进行循环条件的判断，如果条件为 true ，则执行循环体内代码；如果为 false ，则直接退出循环 3、执行循环变量变化部分，改变循环变量的值，以便进行下一次条件判断 4、依次重新执行、、，直到退出循环 特点： 相比 while 和 do...while 语句结构更加简洁易读 注意： 1、for 关键字后面括号中的三个表达式必须用 “;” 隔开，三个表达式都可以省略，但 “;” 不能省略。 a. 省略“循环变量初始化”，可以在 for 语句之前由赋值语句进行变量初始化操作，如: int i = 0; for (; i b. 省略“循环条件”，可能会造成循环将一直执行下去，也就是我们常说的“死循环”现象，如: for (int i = 0; ; i++) { // do something } 在编程过程中要避免“死循环”的出现，因此，对于上面的代码可以在循环体中使用 break 强制跳出循环。 c. 省略“循环变量变化”，可以在循环体中进行循环变量的变化，如： for (int i = 0; i 2、for 循环变量初始化和循环变量变化部分，可以是使用 “,” 同时初始化或改变多个循环变量的值，如： for (int i = 1, j = 5; i 代码中，初始化变量部分同时对两个变量 i 和 j 赋初值，循环变量变化部分也同时对两个变量进行变化。 3、循环条件部分可以使用逻辑运算符组合的表达式，表示复杂判断条件，但一定注意运算的优先级，如： for (int i = 1; i 代码中，必须同时满足变量 i 小于 10 ，并且 i 不等于 5 时才会进行循环，输出变量 i 的值。 break for (int i = 0; i continue for (int i = 0; i 编程题 /* * 为指定成绩加分，直到分数大于等于 60 为止， * 输出加分前和加分后的成绩，并统计加分的次数 */ Test1.java package com.test1; import java.util.Scanner; /* * 为指定成绩加分，直到分数大于等于 60 为止， * 输出加分前和加分后的成绩，并统计加分的次数 */ /* * 使用Scanner工具类来获取用户输入的成绩信息 * Scanner类位于java.util包中，使用时需要导入 * 步骤： * 1.导入java.util.Scanner * 2.创建Scanner对象 * 3.接收并保存用户输入的值 */ public class Test1 { public static void main(String[] args) { // create Scanner Object Scanner input = new Scanner(System.in); // notice // println输出后会换行，print不会 System.out.print(\"请输入考试成绩（整数）：\"); // score // get user input score, and save to variable int score = input.nextInt(); // count int count = 0; System.out.println(\"origin score: \" + score); while (score /* * 求3个班级，各4名学生的平均成绩 */ Test2.java package com.test2; import java.util.Scanner; /* * 求3个班级，各4名学生的平均成绩 */ public class Test2 { public static void main(String[] args) { Scanner input = new Scanner(System.in); int classNum = 3; int studentNum = 4; int score; double sum; double avgs; for (int i = 1; i © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/first-season/array.html":{"url":"pages/first-season/array.html","title":"数组","keywords":"","body":"数组 int[] scores = { 1, 2, 3, 4, 5, 6, 7 } System.out.println(scores[2]); // 3 声明数组 语法： 数据类型[ ] 数组名； // 或者 数据类型 数组名[ ]； 其中，数组名可以是任意合法的变量名，如： // 存储学生成绩的数组，类型为整型 int[] scores; // 存在身高的数组，类型为浮点型 double height[]; // 存储学生姓名的数组，类型为字符串 String[] names; 分配空间 简单地说，就是指定数组中最多可存储多少个元素 语法： 数组名 = new 数据类型 [ 数组长度 ]; 其中，数组长度就是数组中能存放元素的个数，如： scores = new int[5]; height = new double[5]; names = new String[5]; 也可以将上面的两个步骤合并，在声明数组的同时为它分配空间 int[] scores = new int[5]; 赋值 scores[0] = 100; scores[1] = 99; 处理数组中数据 System.out.println(scores[1]); // 99 同时声明数组、分配空间和赋值： int[] scores = {89, 90, 100, 78}; public class HelloWorld { public static void main(String[] args) { // 定义一个长度为5的字符串数组，保存考试科目信息 String[] subjects = new String[5]; // 分别为数组中的元素赋值 subjects[0] = \"Oracle\"; subjects[1] = \"PHP\"; subjects[2] = \"Linux\"; subjects[3] = \"Java\"; subjects[4] = \"HTML\"; System.out.println(\"数组中第4个科目为：\" + subjects[3]); } } 例子： // error: // Cannot define dimension expressions when an array initializer is provided int[ ] score = new int[ 4 ] { 90, 12, 34, 77 }; // error: // Variable must provide either dimension expressions // or an array initializer int[ ] score = new int[ ]; // right int score[ ] = new int[ ] { 34, 90, 87, 54, 24 }; 循环操作 int[] arr = { 34, 53, 98, 23}; for (int i = 0; i 获取数组的长度语法 数组名.length 数组下标的范围是 0 至 数组长度-1 ，如果越界访问，就会报错。 // Array.java Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 4 at com.array.Array.main(Array.java:15) 练习： 输出数组中的最大值、最小值和平均值 public class Array { public static void main(String[] args) { // 定义一个整型数组，并赋初值 int[] nums = new int[] { 61, 23, 4, 74, 13, 148, 20 }; int max = nums[0]; // 假定最大值为数组中的第一个元素 int min = nums[0]; // 假定最小值为数组中的第一个元素 double sum = 0;// 累加值 double avg = 0;// 平均值 for (int i = 0; i 0 && nums[i] > max) { max = nums[i]; } // 如果当前值小于min，则替换min的值 if (i > 0 && nums[i] 使用 Arrays 类操作 Java 中的数组 Arrays 类是 Java 中提供的一个工具类，在 java.util 包中。该类中包含了一些方法用来直接操作数组，比如可直接实现数组的排序、搜索等 排序 sort() // 语法： Arrays.sort(数组名); public class Array { public static void main(String[] args) { // 定义一个整型数组，并赋初值 int[] nums = new int[] { 61, 23, 4, 74, 13, 148, 20 }; Arrays.sort(nums); System.out.println(\"排序后的首尾数为：\" + nums[0] + \", \" + nums[nums.length - 1]); System.out.println(\"toString: \" + Arrays.toString(nums)); } } 将数组转换为字符串 toString() // 语法： Arrays.toString(数组名); foreach foreach 并不是 Java 中的关键字，是 for 语句的特殊简化版本，在遍历数组、集合时， foreach 更简单便捷。 [!TIP|style:flat|label:语法] for (元素类型 元素变量 : 遍历对象) { // do something } for (int i : nums) { System.out.println(\"print by foreach: \" + i); } 二维数组 声明数组/分配空间 数据类型[][] 数组名 = new 数据类型[行数][列数]; 或 数据类型[][] 数组名; 数组名 = new 数据类型[行数][列数]; CODE Array.java package com.array; import java.util.Arrays; /* public class Array { public static void main(String[] args) { // right: int score[] = new int[]{45, 56, 76, 23}; // error: // Cannot define dimension expressions // when an array initializer is provided // int score[] = new int[4]{45, 56, 76, 23}; // error: // Variable must provide either dimension expressions // or an array initializer // int[ ] score = new int[ ]; System.out.println(score[4]); } } */ /* public class Array { public static void main(String[] args) { // 定义一个整型数组，并赋初值 int[] nums = new int[] { 61, 23, 4, 74, 13, 148, 20 }; int max = nums[0]; // 假定最大值为数组中的第一个元素 int min = nums[0]; // 假定最小值为数组中的第一个元素 double sum = 0;// 累加值 double avg = 0;// 平均值 for (int i = 0; i 0 && nums[i] > max) { max = nums[i]; } // 如果当前值小于min，则替换min的值 if (i > 0 && nums[i] Test.java package com.array; import java.util.Arrays; /* * 创建指定长度的 int 型数组， * 并生成 100 以内随机数为数组中的每个元素赋值， * 然后输出数组 */ //public class Test { // public static void main(String[] args) { // Test ts = new Test(); // // create array // int[] arr = ts.createArray(8); // // System.out.println(Arrays.toString(arr)); // } // // public int[] createArray(int length) { // int[] arr = new int[length]; // for (int i = 0; i = 3) break; if (scores[i] >= 0 && scores[i] arr[i]) { temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } return arr; } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/first-season/function.html":{"url":"pages/first-season/function.html","title":"方法","keywords":"","body":"方法 语法 访问修饰符 返回值类型 方法名(参数列表) { 方法体 } 访问修饰符： 方法允许被访问的权限范围，可以是 public、protected、private 甚至可以省略。其中 public 表示该方法可以被其他任何代码调用。 返回值类型： 方法返回值的类型，如果方法不返回任何值，则为 void；如果有返回值，则需要指定返回值的类型，并且在方法体中使用 return 语句返回值。 方法名： 定义的方法的名字，必须使用合法的标识符。 参数列表： 传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开。 根据方法是否带参、是否带返回值，可将方法分为四类: Ø 无参无返回值方法 Ø 无参带返回值方法 Ø 带参无返回值方法 Ø 带参带返回值方法 public void print(String str) { System.out.println(str); } 例子 // Func.java public class Func { // 定义print方法 public void print(String str) { System.out.println(str); } public static void main(String[] args) { // 创建Func对象 Func fn = new Func(); // 调用print方法 fn.print(\"Hello world\"); } } 无参带返回值方法 public int sum() { int a = 1; int b = 3; return a + b; } 1、如果方法的返回类型为 void ，则方法中不能使用 return 返回值！ 2、方法的返回值最多只能有一个，不能返回多个值。 3、方法返回值的类型必须兼容，例如，如果返回值类型为 int ，则不能返回 String 型值。 带参无返回值方法 public int sum(int a, int b) { System.out.println(a + b); } 1、调用带参方法时，必须保证实参的数量、类型、顺序与形参一一对应 2、调用方法时，实参不需要指定数据类型 3、方法的参数可以是基本数据类型，如 int、double 等，也可以是引用数据类型，如 String、数组等 4、当方法参数有多个时，多个参数间以逗号分隔。 带参有返回值方法 public int sum(int a, int b) { return a + b; } Java 中方法的重载 [!TIP|style:flat|label:什么是方法的重载呢？] 如果同一个类中包含了两个或两个以上方法名相同、方法参数的个数、顺序或类型不同的方法，则称为方法的重载，也可称该方法被重载了。如下所示 4 个方法名称都为 show ，但方法的参数有所不同，因此都属于方法的重载： // 无参数方法 public void show() { System.out.println(\"not arguments\"); } // 重载show方法，一个字符串参数 public void show(String name) { System.out.println(\"argument name: \" + name); } // 重载show方法，两个参数 public void show(String name, int age) { System.out.println(name + \" is \" + age + \" years old\"); } // 重载show方法，两个参数顺序不同 public void show(int age, String name) { System.out.println(\"The \" + age + \"-year-old people is \" + name + \".\"); } [!TIP|style:flat|label:如何区分调用的是哪个重载方法呢？] 当调用被重载的方法时， Java 会根据参数的个数和类型来判断应该调用哪个重载方法，参数完全匹配的方法将被执行。如： public static void main(String[] args) { Func fn = new Func(); fn.show(); // 调用无参数的show方法 fn.show(\"Juny\"); // 调用带有一个参数的show方法 fn.show(\"Juny\", 15); // 调用带有字符串+整型参数的show方法 } 判断方法重载的依据： 1、必须是在同一个类中 2、方法名相同 3、方法参数的个数、顺序或类型不同 4、与方法的修饰符或返回值没有关系 Test.java package com.test; import java.util.Arrays; /* * 创建指定长度的 int 型数组， * 并生成 100 以内随机数为数组中的每个元素赋值， * 然后输出数组 */ public class Test { public static void main(String[] args) { Test ts = new Test(); // create array int[] arr = ts.createArray(8); System.out.println(Arrays.toString(arr)); } public int[] createArray(int length) { int[] arr = new int[length]; for (int i = 0; i CODE Func.java package com.array; public class Func { public void print(String str) { System.out.println(str); } public int sum() { int a = 1; int b = 3; return a + b; } public static void main(String[] args) { Func f = new Func(); f.print(\"Hello world\" + f.sum()); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/regular-expression/":{"url":"pages/regular-expression/","title":"Java正则表达式","keywords":"","body":"Java正则表达式 正则表达式定义了字符串的模式；可以用来搜索、编辑或处理文本。在不种语言中正则表达式有细微的差别。 regular expression 英 [ˈreɡjələ(r) ɪkˈspreʃn] 美 [ˈreɡjələr ɪkˈspreʃn] 正则表达式;正规表达式;正則表達式;规则表达式;正规式 java.util.regex包 java.util.regex 包主要包括以下三个类： Pattern 类： pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher 类： Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。 PatternSyntaxException： PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 正则表达式语法 字符 说明 \\ 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，\"n\"匹配字符\"n\"。\\n匹配换行符。序列\\\\\\\\匹配\\\\，\\\\(匹配(。 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与\\n或\\r之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与\\n或\\r之前的位置匹配。 * 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配z和zoo。* 等效于 {0,}。 + 一次或多次匹配前面的字符或子表达式。例如，zo+与zo和zoo匹配，但与z不匹配。+ 等效于 {1,}。 ? 零次或一次匹配前面的字符或子表达式。例如，do(es)?匹配do或does中的do。? 等效于 {0,1}。 {n} n 是非负整数。正好匹配 n 次。例如，o{2}与Bob中的o不匹配，但与food中的两个o匹配。 {n,} n 是非负整数。至少匹配 n 次。例如，o{2,}不匹配\"Bob\"中的\"o\"，而匹配\"foooood\"中的所有 o。o{1,}等效于o+。o{0,}等效于o*。 {n,m} m 和 n 是非负整数，其中 n 。匹配至少 n 次，至多 m 次。例如，o{1,3}匹配\"fooooood\"中的头三个 o。o{0,1} 等效于 o?。注意：不能将空格插入逗号和数字之间。 ? 当此字符紧随任何其他限定符*、+、?、{n}、{n,}、{n,m}之后时，匹配模式是\"非贪心的\"。非贪心的模式匹配搜索到的、尽可能短的字符串，而默认的贪心的模式匹配搜索到的、尽可能长的字符串。例如，在字符串\"oooo\"中，o+?只匹配单个\"o\"，而o+匹配所有\"o\"。 . 匹配除\\r\\n之外的任何单个字符。若要匹配包括\\r\\n在内的任意字符，请使用诸如[\\s\\S]之类的模式。 (pattern) 匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果\"匹配\"集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用\"(\"或者\")\"。 (?:pattern) 匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用or字符 (VERTICAL__LINE) 组合模式部件的情况很有用。例如，industr(?:yVERTICAL__LINEies) 是比 industryVERTICAL__LINEindustries 更经济的表达式。 (?=pattern) 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，Windows (?=95VERTICAL__LINE98VERTICAL__LINENTVERTICAL__LINE2000) 匹配\"Windows 2000\"中的\"Windows\"，但不匹配\"Windows 3.1\"中的\"Windows\"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 (?!pattern) 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，Windows (?!95VERTICAL__LINE98VERTICAL__LINENTVERTICAL__LINE2000) 匹配\"Windows 3.1\"中的 \"Windows\"，但不匹配\"Windows 2000\"中的\"Windows\"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 xVERTICAL__LINEy 匹配 x 或 y。例如，zVERTICAL__LINEfood 匹配\"z\"或\"food\"。(zVERTICAL__LINEf)ood 匹配\"zood\"或\"food\"。 [xyz] 字符集。匹配包含的任一字符。例如，[abc]匹配\"plain\"中的\"a\"。 [^xyz] 反向字符集。匹配未包含的任何字符。例如，[^abc]匹配\"plain\"中\"p\"，\"l\"，\"i\"，\"n\"。 [a-z] 字符范围。匹配指定范围内的任何字符。例如，[a-z]匹配\"a\"到\"z\"范围内的任何小写字母。 [^a-z] 反向范围字符。匹配不在指定的范围内的任何字符。例如，[^a-z]匹配任何不在\"a\"到\"z\"范围内的任何字符。 \\b 匹配一个字边界，即字与空格间的位置。例如，er\\b匹配\"never\"中的\"er\"，但不匹配\"verb\"中的\"er\"。 \\B 非字边界匹配。er\\B匹配\"verb\"中的\"er\"，但不匹配\"never\"中的\"er\"。 \\cx 匹配 x 指示的控制字符。例如，\\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是\"c\"字符本身。 \\d 数字字符匹配。等效于 [0-9]。 \\D 非数字字符匹配。等效于 [^0-9]。 \\f 换页符匹配。等效于 \\x0c 和 \\cL。 \\n 换行符匹配。等效于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等效于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r\\t\\v] 等效。 \\S 匹配任何非空白字符。与 [^ \\f\\n\\r\\t\\v] 等效。 \\t 制表符匹配。与 \\x09 和 \\cI 等效。 \\v 垂直制表符匹配。与 \\x0b 和 \\cK 等效。 \\w 匹配任何字类字符，包括下划线。与[A-Za-z0-9_]等效。 \\W 与任何非单词字符匹配。与[^A-Za-z0-9_]等效。 \\xn 匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，\\x41匹配\"A\"。\\x041与\\x04&1等效。允许在正则表达式中使用 ASCII 代码。 \\num 匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，(.)\\1匹配两个连续的相同字符。 \\n 标识一个八进制转义码或反向引用。如果 \\n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。 \\nm 标识一个八进制转义码或反向引用。如果 \\nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \\nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \\nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。 \\nml 当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。 \\un 匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\\u00A9 匹配版权符号 (©)。 注：VERTICAL_LINE 为 | 符号。 参考资料 https://www.runoob.com/java/java-regular-expressions.html © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/second-season/class-and-object.html":{"url":"pages/second-season/class-and-object.html","title":"类与对象","keywords":"","body":"类和对象 面向对象 1、对象的概念 2、什么是面向对象 3、类 4、什么是对象的属性 5、什么是对象的方法 6、类与对象的关系/区别 对象的概念 万物皆对象，客观存在的事物皆为对象。 什么是面向对象 人 -> 关注 -> 事物信息 类 类是模子，确定对象将会拥有的特征（属性）和行为（方法）。 类的特点：类是对象的类型，具有相同属性和方法的一组对象的集合。 什么是对象的属性 属性：对象具有的各种特征，每个对象的每个属性都拥有特定值。 什么是对象的方法 方法：对象执行的操作。 类与对象的关系/区别 类是抽象的概念，仅仅是模板，比如说\"手机\"； 对象是一个你能够看得到，摸得着的具体实体。 \"手机\"类 对象 特征（属性）屏幕/CPU/内存 华为, 小米... 行为（方法）打电话/发短信 华为, 小米... 类的定义 类的重要性：所有Java程序都以 类class 为组织单元。 类的组成：属性和方法。 定义一个类的步骤： 定义类名，编写类的属性，编写类的方法 语法 public class 类名 { // 定义属性部分（成员变量） 类型 属性1; 类型 属性2; ... 类型 属性n; // 定义方法部分 方法1; 方法2; ... 方法n; } 例子 // Telphone.java package com.phone; // 1. 定义一个类Telphone public class Telphone { // 2. 属性（成员变量） float screenSize; float cpu; float memory; // 3. 方法 干什么 vodi call() { System.out.println(\"Telphone有打电话的功能\"); } vodi sendMessage() { System.out.println(\"Telphone有发短信的功能\"); } } 使用对象 使用对象的步骤： 1、创建对象 类名 对象名 = new 类名(); Telphone phone = new Telphone(); 2、使用对象 引用对象的属性：对象名.属性 // 给screenSize属性赋值5 phone.screenSize = 5; 引用对象的方法：对象名.方法名() // 调用sendMessage()方法 phone.sendMessage(); 完整例子： com.test/Telphone.java public class Telphone { float screenSize; float cpu; float memory; void call() { System.out.println(\"call\"); } void sendMessage() { System.out.println(\"screenSize: \" + screenSize + \", cup: \" + cpu + \", memory: \" + memory); } } com.test/useTelphone.java public class useTelphone { public static void main(String[] args) { // TODO Auto-generated method stub Telphone phone = new Telphone(); phone.sendMessage(); // 赋值 phone.screenSize = 5.4f; phone.cpu = 1.4f; phone.memory = 4.0f; phone.sendMessage(); } } 成员变量和局部变量 1、成员变量：在 类 中定义，用了描述对象将要有什么。 2、局部变量：在类的 方法 中定义，在方法中临时保存数据。 区别 成员变量 局部变量 作用域 在整个类内部都是可见的 仅限于定义它的方法中 初始值 Java会给成员变量一个初始值，调用时可以不赋值 不会赋初始值，调用前必须赋值 同一个方法中，不允许有同名局部变量。 两类变量同名时，局部变量具有更高的优先级（就近原则）。 构造方法 1、使用new 构造方法 创建一个新的对象。 2、构造方法是定义在Java类中的一个用来初始化对象的方法，构造方法与类同名且没有返回值。 3、无参构造方法的使用 main(): Telphone phone = new Telphone(); class Telphone: public Telphone() { System.out.println(\"Telphone Constractor\"); } 4、带参构造方法的使用 main(): Telphone phone2 = new Telphone(5.0f); class Telphone: public Telphone(float newScreen) { screen = newScreen; } 5、当没有指定构造方法时，系统会自动添加无参的构造方法。 6、当有指定构造方法，无论是有参、无参的构造方法，系统都不会自动添加无参的构造方法。 7、构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应的方法。 8、构造方法不但可以给对象的属性赋值，还可以保证给对象的属性赋一个合理的值 pubilc class Tp { private float screen; public Tp() { System.out.println(\"com.test Tp无参构造方法执行了\"); } public Tp(float newScreen) { if (newScreen Java 中的 static 使用之静态变量 Java 中被 static 修饰的成员称为 静态成员 或 类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。 静态成员可以使用类名直接访问，也可以使用对象名进行访问。当然，鉴于他作用的特殊性更推荐 用类名访问 ~~ 使用 static 可以修饰变量、方法和代码块。 public class TestStatic { // static 修饰的变量为静态变量，所有类的对象共享hobby static String hobby = \"Hello World\"; public static void main(String[] args) { // 静态变量可以直接使用类名来访问，无需创建类的对象 System.out.println(\"通过类名访问hobby：\" + TestStatic.hobby); // 创建类的对象 TestStatic ts = new TestStatic(); // 使用对象名称来访问静态变量 System.out.println(\"通过对象名访问hobby：\" + ts.hobby); // 使用对象名的形式修改静态变量的值 ts.hobby = \"Hello Space\"; // 再次使用类名访问静态变量，值已被修改 System.out.println(\"通过类名访问修改后的hobby：\" + TestStatic.hobby); } } 运行结果： 通过类名访问hobby：Hello World 通过对象名访问hobby：Hello World 通过类名访问修改后的hobby：Hello Space [!WARNING|style:flat|label:注意] 静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收！ 1、java中 静态方法 不可以直接调用非静态方法和成员，也不能使用this关键字。 原因解释：类中静态的方法或者属性，本质上来讲并不是该类的成员，在java虚拟机装载类的时候，这些静态的东西已经有了对象，它只是在这个类中\"寄居\"，不需要通过类的构造器（构造函数）类实现实例化；而非静态的属性或者方法，在类的装载是并没有存在，需在执行了该类的构造函数后才可依赖该类的实例对象存在。所以在静态方法中调用非静态方法时，编译器会报错 （Cannot make a static reference to the non-static method func() from the type A）。 2、java中不能将方法体内的局部变量声明为static。 3、非静态成员的可以随便调用静态成员。 Java 中的 static 使用之静态方法 与静态变量一样，使用 static 修饰的方法，称为静态方法或类方法。比如之前使用的 main 方法就是静态方法。静态方法的使用如： public class TestStaticFunc { // 使用static关键字声明静态方法 public static void print() { System.out.println(\"Welcome to Java World.\"); } public static void main(String[] args) { // 直接使用类名调用静态方法 TestStaticFunc.print(); // 也可以通过对象名调用，当然推荐使用类名调用方式 TestStaticFunc tsf = new TestStaticFunc(); tsf.print(); } } 1、静态方法中可以直接调用同类中的 静态成员，但不能直接调用 非静态成员。 public class TestStatic { // static 修饰的变量为静态变量，所有类的对象共享hobby static String hobby = \"Hello World\"; // 非静态变量 String name = \"非静态变量name\"; public static void main(String[] args) { // 直接使用静态变量 System.out.println(\"直接调用静态变量：\" + hobby); // 静态方法中，不能直接调用非静态变量 System.out.println(\"这是：\" + name); // x Error } } 如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量 public class TestStatic { // 非静态变量 String name = \"非静态变量name\"; public static void main(String[] args) { // 创建类的对象 TestStatic ts = new TestStatic(); // 通过对象来实现静态方法中调用非静态变量 System.out.println(\"通过对象名访问name：\" + ts.name); } } 2、在普通成员方法中，则可以直接访问 同类 的非静态变量和静态变量 // static 修饰的变量为静态变量，所有类的对象共享hobby static String hobby = \"Hello World\"; // 非静态变量 String name = \"非静态变量name\"; public void print() { System.out.println(\"这是：\" + name); System.out.println(\"静态变量：\" + hobby); } 3、静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法 public class TestStatic { // static 修饰的变量为静态变量，所有类的对象共享hobby static String hobby = \"Hello World\"; // 非静态变量 String name = \"非静态变量name\"; public void print() { System.out.println(\"这是：\" + name); System.out.println(\"静态变量：\" + hobby); } public static void show() { System.out.println(\"这是静态方法show()\"); } public static void main(String[] args) { // 创建类的对象 TestStatic ts = new TestStatic(); // 普通成员方法必须通过对象来调用 ts.print(); // 可以直接调用静态方法 show(); } } Java 中的 static 使用之静态初始化块 Java 中可以通过初始化块进行数据赋值 public class Hello { String name; // 定义一个成员变量 // 通过初始化块，为成员变量赋值 { name = \"hello\"; } } 在类的声明中，可以包含多个初始化块，当创建类的实例时，就会依次执行这些代码块。如果使用 static 修饰初始化块，就称为静态初始化块。 [!WARNING|label:注意|style:flat] 静态初始化块只在 类加载时执行，且 只会执行一次，同时静态初始化块 只能给静态变量赋值，不能初始化普通的成员变量。 public class TestStaticBlock { int num1; int num2; static int num3; public TestStaticBlock() { num1 = 1000; System.out.println(\"通过【构造方法】为变量num1赋值\"); } // 初始化块 { num2 = 2000; System.out.println(\"通过【初始化块】为变量num2赋值\"); } // 静态初始化块 static { num3 = 3000; System.out.println(\"通过【静态初始化块】为变量num3赋值\"); } public static void main(String[] args) { // 创建类的对象tsb TestStaticBlock tsb = new TestStaticBlock(); System.out.println(\"num1: \" + tsb.num1); System.out.println(\"num2: \" + tsb.num2); System.out.println(\"num3: \" + num3); System.out.println(\"---- 华丽的分割线 ------------------------------\"); // 再创建类的对象tsb2 TestStaticBlock tsb2 = new TestStaticBlock(); } } 结果： 通过【静态初始化块】为变量num3赋值 通过【初始化块】为变量num2赋值 通过【构造方法】为变量num1赋值 num1: 1000 num2: 2000 num3: 3000 ---- 华丽的分割线 ------------------------------ 通过【初始化块】为变量num2赋值 通过【构造方法】为变量num1赋值 [!WARNING|style:flat|label:通过输出结果，我们可以看到] 程序运行时静态初始化块最先被执行，然后执行普通初始化块，最后才执行构造方法。由于静态初始化块只在类加载时执行一次，所以当再次创建对象 tsb2 时并未执行静态初始化块。 代码 public class HelloWorld { int num1; int num2; static int num3; public HelloWorld () { num1 = 91; System.out.println(\"通过构造方法为变量num1赋值\"); } { num2 = 74; System.out.println(\"通过初始化块为变量num2赋值\"); } static { num3 = 3; System.out.println(\"通过静态初始化块为静态变量num3赋值\"); } public static void main (String[] args) { HelloWorld h = new HelloWorld(); System.out.println(\"num1: \" + h.num1); System.out.println(\"num2: \" + h.num2); System.out.println(\"num3: \" + HelloWorld.num3); HelloWorld h2 = new HelloWorld(); } } 结果 通过静态初始化块为静态变量num3赋值 通过初始化块为变量num2赋值 通过构造方法为变量num1赋值 num1: 91 num2: 74 num3: 3 通过初始化块为变量num2赋值 通过构造方法为变量num1赋值 原教程出处 https://www.imooc.com/learn/124 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/second-season/encapsulation.html":{"url":"pages/second-season/encapsulation.html","title":"面向对象特性：封装","keywords":"","body":"封装 面向对象特性三大特性：封装、继承、多态 概念 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和方法。 好处 只能通过规定的方法访问数据 隐藏类的实例细节，方便修改和实现 封装的实现步骤 例子 public class Hello { provite float screen; // getter public float getScreen() { return screen; } // setter public void setScreen(float newScreen) { screen = newScreen; } } java中的包 1、作用 管理Java文件 解决同名文件冲突 2、包的定义：package 包名 [!WARNING|style:flat|label:注意] 必须放在Java源程序的第一行，包名间可以使用 . 号隔开，eg: com.test.HelloWorld // 例子：音乐类-MyClassMusic // music com.test.music.MyClassMusic; // movie com.test.movie.MyClassMusic; 3、系统中的包 java.(功能).(类) 包名 说明 java.lang.(类) 包含java语言基础的类 java.util.(类) 包含java语言中各种工具类 java.io.(类) 包含输入、输出相关功能的类 4、包的使用 可以通过import关键字，在某个文件使用其它文件中的类。 import com.test.music.MyClass; [!WARNING|style:flat|label:注意] Java中，包的命名规范是全小写字母拼写 使用的时候不但可以加载某个包下面的所有文件 com.test.*; 也可以加载某个具体包下的所有文件 com.test.music.*; Java中的访问修饰符 class Telphone { private float screen = 5.0f; public float getScreen() { return screen; } publick void setScreen(float newScreen) { screen = newScreen; } // ... } 访问修饰符，可以修饰 属性 和 方法 的访问范围。 访问修饰符 本类 同包 子类 其他 private o - - - 默认 o o - - protected o o o - public o o o o Java中的this关键字 1、this关键字代表当前对象 this.属性 操作当前对象的属性 this.方法 调用当前对象的方法 2、封装对象的属性的时候，经常会使用this关键字 # Eclipse编辑器自动生成getter/setter 菜单栏 -> source -> Generate Getters and Setters ... # 指定需要生成getter或setter方法的属性 class Telphone { private float screen = 5.0f; public float getScreen() { return screen; } publick void setScreen(float screen) { this.screen = screen; } // ... } Java中的内部类 内部类（Inner Class）就是定义在另外一个类里的类。与之对应，包含内部类的类被称为外部类。 内部类的主要作用如下： 1、内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类 2、内部类的方法可以直接访问外部类的所有数据，包括私有的数据 3、内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便 内部类可分为以下几种： 成员内部类 静态内部类 方法内部类 匿名内部类 成员内部类 public class Outer { int outerNumber = 10; // 成员内部类 public class Inner { int innerNumber = 20; public void print () { System.out.println(\"Inner class's print method, and outerNumber=\" + outerNumber); } } public static void main (String[] args) { // 创建外部类对象 Outer ou = new Outer(); // 创建内部类对象 Inner in = ou.new Inner(); // 调用内部类对象方法 in.print(); } } 成员内部类的使用方法： 1、Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 public 、 protected 、 private 等 2、Inner 类中定义的 print() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性a 3、定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即： 内部类 对象名 = 外部类对象.new 内部类( ); 4、编译上面的程序后，会发现产生了两个 .class 文件 其中，第二个是外部类的 .class 文件，第一个是内部类的 .class 文件，即成员内部类的 .class 文件总是这样： 外部类名$内部类名.class [!WARNING|style:flat|label:注意] 1、外部类不能直接使用内部类的成员和方法 可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。 [!WARNING|style:flat|label:注意] 2、如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this关键字。如： 运行结果： 访问外部类中的b：1 访问内部类中的b：2 静态内部类 静态内部类是 static 修饰的内部类，这种内部类的特点是： 1、静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问 2、如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员 3、创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类(); 结果： 访问外部类中的b:1 访问内部类中的b:2 方法内部类 方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。 [!WARNING|style:flat|label:注意] 由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/second-season/inheritance.html":{"url":"pages/second-season/inheritance.html","title":"面向对象特性：继承","keywords":"","body":"继承 继承是类与类的一种关系，是一种is a的关系。 [!TIP|style:flat] Java中的继承是单继承。 优点： 1、子类拥有父类的所有属性和方法。private修饰符的属性和方法除外。 2、复用父类的代码（代码复用）。 语法： class 子类 extends 父类 例子 // Animal.java class Animal { // 相当于JavaScript的constructor public Animal() { // ... } public name; public age; public void eat() { System.out.println(\"调用了Animal的eat方法\"); } } // Dog.java class Dog extends Animal { } // Initial.java class Initial { public static void main() { Dog dog = new Dog(); dog.name = \"DD\"; dog.age = 2; dog.eat(); } } 方法的重写 如果子类对继承父类的方法不满意，可以重写父类继承的方法，当调用方法时会优先调用子类的方法。 语法规则： 返回值类型，方法名，参数类型及个数都要与父类继承的方法相同，才叫方法的重写 继承的初始化顺序 初始化父类再初始化子类 先执行初始化对象中属性，再执行构造方法中的初始化 final 关键字 使用final关键字做标识有最终的含义 1、final可以修饰类、方法、属性和变量 2、final修饰类，则该类不允许被继承 3、final修饰方法，则该方法不允许被覆盖（重写） 4、final修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值），或在构造方法中赋值（但只能选其一）。 5、final修饰变量，则该变量的值只能赋一次值，即变为常量。 final public class Animal { // ... } super 关键字 在对象的内部使用，可以代表父类对象。 访问父类的属性 super.age 访问父类的方法 super.eat() 例子 // Dog.java public void method() { System.out.println(super.age); } super的应用 1、子类的构造的过程当中必须调用其父类的构造方法。 2、如果子类的构造方法中没有显式调用父类的构造方法，则系统默认调用父类无参的构造方法。 3、如果显式的调用构造方法，必须在子类的构造方法的第一行。 // Dog.java public class Animal { // constructor public Animal() { super(); // 必须放在第一行 // ... } } 4、如果子类构造方法中既没有显式调用父类的构造方法，而父类又没有无参的构造方法，则编译就会出错。 Object类 Object类是所有类的父类，如果一个类没有使用extends关键字明确标识继承另外一个类，那么这个类默认继承Object类。 Object类中的方法，适合所有子类。 1、toString()方法 在Object类里面定义toString()方法的时候，返回的对象的哈希code码（对象地址字符串） 可以通过重写toString()方法表示出对象的属性 # Eclipse快速重写toString 菜单栏 -> source -> Generate toString 2、equals()方法 比较的是对象的引用是否指向同一块内存地址。 一般情况下比较两个对象时，比较他的值是否一致，所以要进行重写。 # Eclipse快速生成 source -> Generate hasCode() and equals()... © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/second-season/polymorphic.html":{"url":"pages/second-season/polymorphic.html","title":"面向对象特性：多态","keywords":"","body":"多态 对象的多种形态。引用多态、方法多态。 [!TIP|style:flat] 继承是多态实现的基础 引用多态 父类的引用可以指向本类的对象。 父类的引用可以指向子类的对象。 方法多态 创建本类对象时，调用的方法为本类方法。 创建子类对象时，调用的方法为子类重写的方法或者继承的方法。 // Animal.java package com.polymorphic; public class Animal { public void eat () { System.out.println(\"Animal has eat method.\"); } } // Dog.java package com.polymorphic; public class Dog extends Animal { // overwrite public void eat () { System.out.println(\"Dogs eat meat.\"); } } // Cat.java package com.polymorphic; public class Cat extends Animal { } // Initial.java package com.polymorphic; public class Initial { public static void main(String[] args) { /* * 引用多态/方法多态 */ // 父类的引用可以指向本类的对象 Animal obj1 = new Animal(); // 父类的引用可以指向子类的对象 Animal obj2 = new Dog(); Animal obj3 = new Cat(); // methods polymorphic obj1.eat(); obj2.eat(); obj3.eat(); /* * 引用类型转换 */ Dog dog = new Dog(); Animal animal = dog; // 自动类型提升，向上类型转换 // Warning // Dog dog2 = animal; // Type mismatch: cannot convert from Animal to Dog Dog dog2 = (Dog)animal; // 向下类型转换 强制类型转换 // error // Cat cat = (Cat)animal; // 编译时Cat类型(不会报错)，运行时Dog类型(抛出异常) // instanceof if (animal instanceof Cat) { Cat cat = (Cat)animal; } else { System.out.println(\"无法进行Cat类型转换\"); } } } 多态中的引用类型转换 向上类型转换（隐式/自动类型转换），是小类型到大类型的转换。 向下类型转换（强制类型转换），是大类型到小类型。容易发送数据溢出。 instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题。 package com.polymorphic; public class Initial { public static void main(String[] args) { /* * 引用多态/方法多态 */ // 父类的引用可以指向本类的对象 Animal obj1 = new Animal(); // 父类的引用可以指向子类的对象 Animal obj2 = new Dog(); Animal obj3 = new Cat(); // methods polymorphic obj1.eat(); obj2.eat(); obj3.eat(); /* * 引用类型转换 */ Dog dog = new Dog(); Animal animal = dog; // 自动类型提升，向上类型转换 // Warning // Dog dog2 = animal; // Type mismatch: cannot convert from Animal to Dog Dog dog2 = (Dog)animal; // 向下类型转换 强制类型转换 // error // Cat cat = (Cat)animal; // 编译时Cat类型(不会报错)，运行时Dog类型(抛出异常) // instanceof if (animal instanceof Cat) { Cat cat = (Cat)animal; } else { System.out.println(\"无法进行Cat类型转换\"); } } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/second-season/abstract.html":{"url":"pages/second-season/abstract.html","title":"抽象类","keywords":"","body":"Java中的抽象类 语法：使用abstract关键字修饰，则该类为抽象类。 [!TIP|style:flat|label:应用场景] 1、在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。（父类规定子类必须包含哪些方法，但不关心子类如何实现） 2、从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。 作用： 限制规定子类必须实现某些方法，但不关心实现细节。 使用规则： 1、abstract 定义抽象类 2、abstract 定义抽象方法，只有声明，不需要实现 3、包含抽象方法的类是抽象类 4、抽象类中可以包含普通的方法，也可以没有抽象方法 5、抽象类不能直接创建，可以定义引用变量 [!WARNING|style:flat|label:注意] 抽象方法没有方法体，以分号直接结束。 public abstract void call(); public abstract void message(); 例子 // Phone.java package com.phone; public abstract class Phone { public abstract void call(); public abstract void message(); } // CellPhone.java package com.phone; public class CellPhone extends Phone { @Override public void call() { // TODO Auto-generated method stub System.out.println(\"以前的手机，是通过键盘来打电话\"); } @Override public void message() { // TODO Auto-generated method stub System.out.println(\"以前的手机，是通过键盘来发短信\"); } } // SmartPhone.java package com.phone; public class SmartPhone extends Phone { @Override public void call() { // TODO Auto-generated method stub System.out.println(\"智能手机，是通过语音来打电话\"); } @Override public void message() { // TODO Auto-generated method stub System.out.println(\"智能手机，是通过语音来发短信\"); } } // Initial.java package com.phone; public class Initial { public static void main(String[] args) { // TODO Auto-generated method stub Phone tel1 = new CellPhone(); tel1.call(); tel1.message(); Phone tel2 = new SmartPhone(); tel2.call(); tel2.message(); } } 思考题： 现有Shape图形类，用Rectangle矩形和Circle圆形子类，求图形的周长和面积 // Shape.java package com.shape; public abstract class Shape { public abstract float getPerimeter(); public abstract float getArea(); } // Circle.java package com.shape; public class Circle extends Shape { final float PI = 3.1415926f; float radius; @Override public float getPerimeter() { // TODO Auto-generated method stub return this.checkRadius() ? 2 * PI * this.radius : 0; } @Override public float getArea() { // TODO Auto-generated method stub return this.checkRadius() ? PI * this.radius * this.radius : 0; } private boolean checkRadius() { if (this.radius == 0) { System.out.println(\"未设置圆半径\"); return false; } return true; } } // Rectangle.java package com.shape; public class Rectangle extends Shape { public float width; public float height; @Override public float getPerimeter() { if (this.width == 0 || this.height == 0) { System.out.println(\"未设置矩形的长或宽\"); return 0; } // TODO Auto-generated method stub return (this.width + this.height) * 2; } @Override public float getArea() { // TODO Auto-generated method stub return this.width * this.height; } } // Initial.java package com.shape; public class Initial { public static void main(String[] args) { // TODO Auto-generated method stub Rectangle rect = new Rectangle(); rect.width = 20.0f; rect.height = 10.0f; System.out.println(\"长方形边长为：\" + rect.getPerimeter() + \"厘米\"); System.out.println(\"长方形面积为：\" + rect.getArea() + \"平方厘米\"); // circle Circle circle = new Circle(); circle.radius = 20.0f; System.out.println(\"圆周为：\" + circle.getPerimeter() + \"厘米\"); System.out.println(\"圆面积为：\" + circle.getArea() + \"平方厘米\"); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/second-season/interface.html":{"url":"pages/second-season/interface.html","title":"接口Interface","keywords":"","body":"接口 接口可以理解为一种特殊的类，由全局常量和公共的抽象方法所组成。 [!TIP|style:flat|label:概念] 类是一种具体实现，而接口定义了某一批类所需要遵守的 规范，接口不关心这些类的内部数据，及类里方法的实现细节，它只规定这些类必须提供某些方法。 在Java8中，接口可以拥有方法体 语法： [修饰符] abstract interface 接口名称 [extends 父接口1, 父接口2...] { 零到多个常量定义... 零到多个抽象方法的定义... } 关键字abstract可以省略，系统自动默认会添加abstract关键字。 接口就是用来被继承、被实现的，修饰符一般建议用public [!WARNING|style:flat|label:注意] 不能使用private和protected修饰接口 接口定义 1、常量： 接口中的属性是常量，即使定义时不添加 public static final 修饰符，系统也会自动加上。 2、方法： 接口中的方法只能是抽象方法，即使定义时不添加 public abstract 修饰符，系统也会自动加上。 使用接口 一个类可以实现一个或多个接口，实现接口使用implements关键字。Java中一个类只能继承一个父类，是不够灵活的，通过实现多个接口来做补充（弥补）。 继承父类实现的接口语法： [修饰符] class 类名 extends 父类 implements 接口1, 接口2... { // 类体部分 // 如果继承了抽象类，则必须实现继承的抽象方法 // 如果遵守了某个接口，则必须实现接口中的抽象方法 } [!WARNING|style:flat|label:注意] 如果 继承了 抽象类，则必须实现继承的类规定的抽象方法 如果 遵守了某个接口，则必须实现接口中的抽象方法 如果要继承父类，则继承父类必须在实现接口以前，即extends与 implements不能交换位置。 // new -> interface // IPlayGame.java package com.phone; public interface IPlayGame { public void playGame(); } // 系统会默认添加abstract关键字 //public abstract interface IPlayGame { // public abstract void playGame(); //} // SmartPhone.java package com.phone; public class SmartPhone extends Phone implements IPlayGame { @Override public void call() { // TODO Auto-generated method stub System.out.println(\"智能手机，是通过语音来打电话\"); } @Override public void message() { // TODO Auto-generated method stub System.out.println(\"智能手机，是通过语音来发短信\"); } @Override public void playGame() { // TODO Auto-generated method stub System.out.println(\"智能手机具有了玩游戏的功能\"); } } // Psp.java package com.phone; public class Psp implements IPlayGame { @Override public void playGame() { // TODO Auto-generated method stub System.out.println(\"PSP具有了玩游戏的功能\"); } } // Initial.java package com.phone; public class Initial { public static void main(String[] args) { // TODO Auto-generated method stub Phone tel1 = new CellPhone(); tel1.call(); tel1.message(); Phone tel2 = new SmartPhone(); tel2.call(); tel2.message(); // Interface IPlayGame ip1 = new SmartPhone(); ip1.playGame(); IPlayGame ip2 = new Psp(); ip2.playGame(); } } 匿名内部类 匿名内部类：就是没有名称的内部类。 接口在使用过程当中，还经常与匿名内部类配合使用。 多用于关注实现，而不关注实现类的名称。 语法： Interface i = new Interface() { public void method() { System.out.println(\"匿名内部类实现接口的方式\"); } } package com.phone; public class Initial { public static void main(String[] args) { // TODO Auto-generated method stub Phone tel1 = new CellPhone(); tel1.call(); tel1.message(); Phone tel2 = new SmartPhone(); tel2.call(); tel2.message(); // Interface IPlayGame ip1 = new SmartPhone(); ip1.playGame(); IPlayGame ip2 = new Psp(); ip2.playGame(); // 匿名内部类实现接口 IPlayGame ip3 = new IPlayGame() { @Override public void playGame() { // TODO Auto-generated method stub System.out.println(\"匿名内部类实现接口的方式\"); } }; ip3.playGame(); // 直接new // Android中使用较为频繁 new IPlayGame() { @Override public void playGame() { // TODO Auto-generated method stub System.out.println(\"直接使用new，实现匿名内部类接口\"); } }.playGame(); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/second-season/UML.html":{"url":"pages/second-season/UML.html","title":"UML(Unified Modeling Language)","keywords":"","body":"UML Unified Modeling Language（UML），统一建模语言或标准建模语言。 是一个支持模型化和软件系统开发的图形化语言。 为软件开发的所以阶段提供模型化和可视化支持。 UML图示 UML 2.2一共定义了14种图示（diagrams）。 常用UML图 用例图（The Use Case Diagram） [!TIP|style:flat|label:The Use Case Diagram] 用例图能够以可视化的方式，表达系统如何满足所收集的业务规则，以及特定的用户需求等信息。 序列图（The Sequence Diagram） [!TIP|style:flat|label:The Sequence Diagram] 序列图用于安装交互发生的一系列顺序，显示对象之间的这些交互。 类图（The Class Diagram） [!TIP|style:flat|label:The Class Diagram] UML类图、业务逻辑和所有支持结构一同被用于定义全部的代码结构。 UML建模工具 Microsoft Office Visio、Rational Rose、PowerDesign三种建模工具应用最广。 参考资料： https://www.cnblogs.com/Ph-one/p/7650624.html https://www.eclipse.org/modeling/mdt/downloads/?project=uml2 https://www.cnblogs.com/silent2012/archive/2011/09/07/2169946.html UML学习入门就这一篇文章 转自：http://www.uml.org.cn/oobject/201309023.asp 1.1 UML基础知识扫盲 UML这三个字母的全称是Unified Modeling Language，直接翻译就是统一建模语言，简单地说就是一种有特殊用途的语言。 你可能会问：这明明是一种图形，为什么说是语言呢?伟大的汉字还不是从图形(象形文字)开始的吗?语言是包括文字和图形的!其实有很多内容文字是无法表达的，你见过建筑设计图纸吗?里面还不是很多图形，光用文字能表达清楚建筑设计吗?在建筑界，有一套标准来描述设计，同样道理，在软件开发界，我们也需要一套标准来帮助我们做好软件开发的工作。UML就是其中的一种标准，注意这可不是唯一标准，只是UML是大家比较推崇的一种标准而已，说不定以后有一个更好的标准可能会取代她呢!UML并不是强制性标准，没有法律规定你在软件开发中一定要用UML，不能用其它的，我们的目标是善用包括UML在内的各种标准，来提高我们软件开发的水平。 UML由1.0版发展到1.1、1.2、...，到现在的2.0、2.x，本书将会以2.x版本为基础开展讨论。网络上、书籍、还有各种UML工具软件，各自基于的UML版本可能会不一样，大家在学习过程中可能会有一些困惑，不过没关系，本课程在某些关键地方会描述1.x与2.x的差异。 UML有什么用? 有很多人认为，UML的主要用途就是软件设计!也有人认为，如果你不是开发人员，是难以理解UML的。 然而我第一次在实际工作中应用UML的却不是软件设计，而是软件需求分析!当时我们和客户面对面沟通调研需求的时候，直接用类图、顺序图、活动图、用例图等UML。我们并没有因此和客户无法沟通，反而是沟通得更加顺畅。客户在我们的引导下，很快就会读懂这些UML图，因为UML图，让我们和客户的沟通效率和效果更好!你可能觉得很神奇，在后续章节中，我将会为你逐一揭开神奇背后的“秘密”。 UML可帮助我们做软件需求分析和软件设计的工作，在我工作中大概各占了50%的比例，当然在你的实际工作中不一定是这样的比例。UML会让你的需求分析或者软件设计工作更上一层楼，本书将会介绍UML在需求分析方面的最佳实践。 告诉你一个秘密，UML应用于软件需求分析时，其学习门槛将会大大降低!语法复杂度会降低，而且你基本不需要掌握软件开发的知识。只要你对软件需求分析感兴趣，认真学习和应用UML，就很有机会成为软件需求分析高手。 UML的分类 结构型的图(Structure Diagram) 类图(Class Diagram) 对象图(Object Diagram) 构件图(Component Diagram) 部署图(Deployment Diagram) 包图(Package Diagram) 行为型的图(Behavior Diagram) 活动图(Activity Diagram) 状态机图(State Machine Diagram) 顺序图(Sequence Diagram) 通信图(Communication Diagram) 用例图(Use Case Diagram) 时序图(Timing Diagram) 本书所描述的UML的各种图的名字，以上述的为准。 UML各种图的中文译名，因为翻译的原因可能会有所不一样，如：Sequence Diagram和Timing Diagram有时候都会被译成“时序图”，这是最让人困扰的地方!Sequence Diagram 除了被译为顺序图，还有序列图的译法。 中国软件行业协会(CSIA)与日本UML建模推进协会(UMTP)共同在中国推动的UML专家认证，两个协会共同颁发认证证书、两国互认，CSIA与UMTP共同推出了UML中文术语标准，该标准全称为：CSIA-UMTP UML中文术语标准v1.0(本书后文将会简称为UML中文术语标准)。本书将会遵循UML中文术语标准，并且我们会同时给出中文译名和英文原名，大家要留意看英文名字噢，这样能帮助你不会被众多的中文译名混淆。 UML图为什么会分为结构型和行为型两种呢? 顾名思义，结构型的图描述的是某种结构，这种结构在某段时间内应该是稳定的，“静态”的;而结构型的图描述的是某种行为，是“动态”的。 分析系统需求时，我们会面对很多业务概念，它们之间会有某些关系，这些内容可以看成是“静态”的，我们可以利用UML的结构性的图来分析。同时，业务会涉及大量的流程、过程等，这些内容是“动态”的，我们可以用行为型的UML图来分析。 在我们软件设计时，我们需要考虑需要那些类、哪些构件、系统最后怎样部署等，这些内容可以看成是“静态”的，我们可以利用UML的结构型的图来设计。同时，我们也需要考虑软件如何和用户交互，类、构件、模块之间如何联系等“动态”内容，我们可以利用行为型的图来设计。 所谓“静态”和“动态”不是绝对的，下文我们将会进一步介绍结构型的UML和行为型的UML。通过下面的学习，你将会初步认识UML的各种图，你可能还会有很多问题，本章的主要目的是让你对UML有一个宏观的认识，带着你的问题继续阅读后面的章节吧! 1.2 结构型的UML(Structure Diagram) 类图(Class Diagram) 某模具系统类图 此图截取自某模具管理系统的业务概念分析图，图中一个一个的矩形就是类，这些类之间有各种线条连接，这些线条表示类之间的关系。类图是分析业务概念的首选，类图可能是使用率最高的UML图。 再看下面这个Person类图，这时软件设计时用到的一个图： Person类图 该Person类有以下属性(Attribute)：Name(姓名),Sex(性别),Department(部门)等，有以下操作(Operation)：Work(工作)等。类有属性和操作，但用类图分析业务模型时，往往不需要使用操作，如图1.1中的类就只有属性。 Attribute有特性、特征等译法，Operation也称作方法，但本书遵循UML中文术语标准，即Attribute为属性，Operation为操作。 对象图(Object Diagram) 一般情况下只有在软件开发中才会使用到对象图，下面的内容以开发的角度来说明对象图，如果你没有开发经验，阅读起来可能有一点难度。 图1.2中的Person类，用代码实例化如下： Person person = new Person(); …… 类(Class)实例化后就是对象(Object)，对象person是类Person的实例，上述代码可以用对象图表示如下： Person类的对象图 对象图和类图的样子很相似，对象是类的实例化，“person : Person”表示对象person是类Person的实例。对象图往往只在需要描述复杂算法时才会使用，画出来的对象图往往不会只有一个对象，该图只画了一个对象，其目的是尽量简化以便读者的理解什么是对象图。 在需求分析工作中基本上不需要使用对象图，从严谨的角度来看某些情况下应该使用对象图，但我往往还是会用类图来处理，这样更加简便而且容易理解。我们将在类图一章再次讲解对象图。 构件图(Component Diagram) 构件图也叫组件图，两个名字均符合UML中文术语标准。 一辆汽车由轮子、发动机等物理部件组成，一个软件往往也是由很多“物理部件”(如：控件、重用构件等)组成的，构件图就是用来描述软件内部物理组成的一种图。下图是某权限构件设计图： 图1.4某权限构件设计图 图1.4右上方有这样标志 的矩形表示一个构件，构件可以再包含构件。 软件需求分析工作中，需要用到构件图的情况不是很多，以下情况除外： 1、待开发的系统需要与第三方的系统、原有系统、某些老系统等交互，这时可用构件图描述交互要求。 2、客户对软件设计有某些特殊要求，这时可用构件图来描述要求。 构件图有时不会单独使用，还会和部署图一起结合使用。 部署图(Deployment Diagram) 部署图是用来描述系统如何部署、本系统与其他系统是怎样的关系的一种图，如下图： 图 1.5 某24小时便利店的管理系统部署图 图中一个个立体的矩形是部署图的“节点”，一个节点表示一个物理的设备，节点之间的线条表示节点间的物理连接关系。 大部分客户都会具备一定的IT基础环境(如具备局域网、一些服务器、某些软件平台等)，软件系统需要基于当前的IT基础环境来规划，这时我们可以使用部署图来做这个规划。 分析系统的需求，不能忽略系统架构、部署、IT架构等方面的要求，我们要基于客户当前的IT基础环境，做一个最符合客户利益的规划。 要活用构件图、部署图来分析需求，需要具备一定的IT基础架构知识和软件设计知识，如果你还不具备相关知识，那么可以考虑抓紧补充相关知识。不过需求分析工作更多的还是分析业务，提炼功能性需求，这部分工作能做好是相当不容易的事情。对于技术方面的非功能性需求分析，可交由有技术背景的专业人士负责。 包图(Package Diagram) Package有“打包”的意思，包图的主要用途是“打包”类图。用类图描述业务概念时，很多时候会因为业务类太多，而导致类图非常庞大，不利于阅读，这时可以将某些类放入“包”中，通过包图来组织业务概念图。 下图是包图的一个示例： 包图 图中好像文件夹样子的就是一个“包”，包之间的线条表示包之间的关系。 1.3 行为型的UML(Behavior Diagram) 活动图、状态机图、顺序图处于三种不同的角度来描述流程，是分析业务流程的三种不同利器，下面将会逐一说明。 活动图(Activity Diagram) 我们将起床到出门上班这个过程画成活动图，可能是这样的： 图 1.7 起床到出门上班的活动图 活动图中的一个圆边框框表示一个“活动”，多个活动之间的带箭头线条表示活动的先后顺序，该图只是表达了一个顺序流程，活动图还可以表达分支结构。如果你以前曾学过流程图的话，你会发现活动图和流程图很相似。活动图可能是三种能表示流程的UML图中最接近我们思维习惯的一种，下面来学习另外两种能表达流程的图。 状态机图(State Machine Diagram) 状态机图又叫状态图，但状态图这个译名并没有译出Machine的意思。 状态机图从某个物品的状态是如何变化的角度来展示流程，下图某请假条审批流程： 图 1.8 请假处理流程 整个请假审批流程是围绕“请假条”这个物体进行的，随着不同的审批阶段，请假条具备不同的状态。我们分析业务流程时会发现很多流程其实是围绕某个物品进行的，这时可考虑使用状态机图。 顺序图(Sequence Diagram) 你去餐厅吃饭，向服务员点餐到服务员送菜上来，这个过程用顺序图可表示如下： 图 1.9 点菜的顺序图 该图有三个“小人”，每个“小人”下面的文字说明(如：顾客)表示其代表的角色。角色与角色之间有一些线条链接，表示角色之间是如何交互的。该图表示的意思是：顾客向服务员点菜后，服务员将点菜信息传递给厨师，然后厨师做菜，最后再由服务员送菜给你。 点菜过程涉及几个环节，每个环节均由不同的角色来负责，如果遇到类似的情况，你可以考虑使用顺序图来分析。用顺序图来分析的好处是能清晰表达整个过程所参与的角色，角色与角色之间的关系，各角色是如何被卷入这个过程当中的。 通信图(Communication Diagram) UML1.1时，该图英文名为Collaboration Diagram;UML2.x时，英文名为Communication Diagram。将英文名字直接翻译，原来的英文名字可译为协作图，而新的英文名字译为通信图。 通信图是顺序图的另外一种画法，点菜的顺序图，如果用通信图来画可表示如下： 图 1.10 点菜的通信图 三个“小人”分表表示三种角色：顾客、服务员、厨师;角色之间有直线联系表示他们之间有关系;带序号的文字和箭头，表示角色之间传递的信息。 顺序图更强调先后顺序，通信图更强调相互之间的关系。我觉得顺序图实用性更好一点，比通信图能表达更多的信息，更容易读懂，在需求分析工作中我基本不会使用通信图。 用例图(Use Case Diagram) 下图是用例图的示意图： 图 1.11 用例图 用例图表达的是什么角色通过软件系统能做什么事情，我们可以使用用例图系统地表达软件系统的绝大部分需求。 时序图(Timing Diagram) 时序图也叫时间图，时序图是UML中文术语标准的说法，而时间图不是标准的说法。 时序图是表示某东西的状态随时间变化而变化的一种图，参见下图： 图 1.12 灯的开关状态随时间变化图 此图表示在0秒到30秒，灯的状态是关的，30-60秒灯的状态为开，60秒后状态为关。 在实际工作中我基本上没有试用过时间图。 下面通过这个表格来总结一下我在需求分析工作中应用各种UML图的情况： 表 1.1 各种UML图实际应用情况 上表是根据我的工作经验总结的，相信会适用于很多情况。但每个人的工作经历、情况、环境等不太一样，上表仅作参考。 1.4 如何学好UML? UML的认识误区 误区一：认为UML主要用于软件设计。 前面的文章你可以看到，UML除了用于软件设计，还能用于需求分析，而本书就是专门来说明如何在需求分析工作中活用UML的。 误区二：客户无法理解UML，在需求分析中应用UML实际意义不大。 我还不熟悉UML时，确实也有这样的怀疑，而实际工作中发现UML恰恰成为与客户沟通的良好桥梁!UML其实不难读懂，只要稍加解释客户马上就能读懂。我在所有的项目需求分析工作中，都直接使用UML图与客户沟通，并且给客户签署的需求规格说明书中含有大量的UML图。 UML能直观、形象、严谨地描述出业务概念、业务流程、客户的期望和需求，只要稍加引导客户，客户将会很容易读懂UML，甚至会主动使用UML与项目组交流。我曾经遇到过客户向我们索要画UML图的工具，客户见识过UML的威力后，也想在自己实际工作中使用。 误区三：认为UML语法繁杂，难以学习和应用。 某些UML资料和书籍可能将UML说得过于复杂了，官方的UML标准资料也确实是枯燥难懂、人见人晕。我刚开始学习UML时，也看过一些UML书籍，觉得UML的语法太多、太复杂、太容易混淆了! 在实际工作中，其实经常需要用到的UML语法并不多，而且很容易掌握。当我们在需求分析方面应用UML时，需要掌握的语法更少(在软件设计方面应用UML时需要掌握稍多一点的语法)。“二八原则”在这里完全适用，我们经常用到的UML语法，其实只占全部语法的20%，而本书将会重点介绍实用性强的UML语法。 误区四：UML用途不大。 很多人推崇UML，但也有不少人士不太认可UML。不认可的原因主要是因为一些人士学习UML后，发现在实际工作中发挥的作用并不是很大，有时候不用UML效果更好。 我不敢说UML能帮助我们解决所有问题，至少从我的多年使用经验上来说，UML对于提升我的需求分析能力帮助还是很大的。有人之所以感觉UML不太好用，我觉得原因还是只掌握了UML的形而没有领会UML的神。UML的常用语法可能几天就能学会了，而要真正做到“thinking in UML”却没有这么容易，需要长期的锻炼。 我的学习经历 我读大学时没有听说过UML，出来工作两三年后才开始接触UML，当时的感觉就好像找到了新大陆，很想好好发掘一番!而我当时的运气还是相当不错的，我的上司是UML达人，他带领我参加了项目的需求分析工作。我很快就见识了UML威力，在他的言传身教之下，迅速掌握了UML。 在那个项目以后，我便独立担当了多个项目管理及需求分析工作，没有一个项目不应用UML，而且我毫不保留地传授UML知识给项目组的其他成员。多年的工作进一步磨练了自己，对UML在实际工作中的应用有了更深刻的认识，形成自己的一套方法。 我的UML知识绝大部分来自于工作实践，期间虽然也看过一些书籍，但对我的帮助很少。当然我最大的得益还是来自我的UML启蒙老师，他在实际工作中教会了我UML，帮助我踏上自我成长的道路。 我的UML学习最大体会就是：实践太重要了!如果有名师指导则会让你事半功倍!希望本书能成为你在实际工作中学习和应用UML的好帮手! UML学习难点 学UML之难，不在于学习语法，关键是要改变思维习惯。UML是一种新的工具，但同时也是代表了一种新的先进的思考方法，如果不能掌握这样的方法，只能学到了UML的形，而没有掌握其神髓。 要用好UML，你需要在平时多多培养下面的能力： 1、书面表达能力。 2、归纳总结能力。 3、“面向对象”的思维能力和抽象能力。 平时你可以利用各种机会来提升第1和第2种能力，如多写写项目文档、写写日记或博客等，多思考和总结平时自己的工作得失等。 第3种能力说起来有点虚，大家在大学中可能也学过相关知识。训练这种能力的最好方法就是多应用类图，我们将会在类图的章节再重点介绍，通过实例来体会什么才叫“面向对象”! 本书将会重点培养你的这三种能力，只要你有进步之心，多练习、多实践、多思考、多总结，一定会取得长足进步! 1.5 小结 本章的主要目标是让你不需要阅读全书的情况下，就可以了解到UML的全貌，大概知道UML各种图的用途，同时给你说明学习UML的难点，为最终活用UML做好准备。下面我们一起来复习一下本章的主要内容： UML是Unified Modeling Language的简称，是软件开发界的一套标准，UML不仅可用于软件设计，也可以用于软件需求分析。但UML并不是强制标准，我们应该善用包括UML在内的各种标准来提高我们的水平。 UML可分为两类：结构型、行为型，结构性的UML有：类图、对象图、构件图、部署图、包图，行为型的图有活动图、状态机图、顺序图、通信图、用例图、时间图。 类图是业务概念模型分析的有利武器，也是面向对象分析能力的强有力训练工具。 对象图在需求分析工作中并不常用。 构件图、部署图是分析IT基础架构、软件架构等方面需求的有利分析工具，但需要你具备IT基础架构、软件设计方面的知识和经验。 包图可用来组织类图，在需求分析工作中应用的机会不是很大。 活动图、状态机图、顺序图是分析业务流程的强力武器。活动图的表达思路与流程图很类似，很容易掌握，而且大部分情况下都可以使用活动图来分析业务流程;某流程如果是围绕某个物品进行，该物品在流程中转换多种状态，那么使用状态机图来分析是首选;用顺序图来分析的好处是能清晰表达整个过程所参与的角色，角色与角色之间的关系，各角色是如何被卷入这个过程当中的。 通信图可以看作是顺序图的另外一种表达形式，顺序图更强调先后顺序，通信图更强调相互之间的关系。而从我的工作经验看，顺序图更加实用一点。 有人会将用例图称作“公仔图”，用例图表达的是什么角色通过软件系统能做什么事情，我们可以使用用例图系统地表达软件系统的绝大部分需求。 时间图是表示某东西的状态随时间变化而变化的一种图，我在实际工作中很少有机会能用到这种图。 学UML之难，不在于学习语法，避免陷入UML的认识误区，多练习、多实践，培养良好的“think in UML”思想，锻炼面向对象分析的能力，成为活用UML的需求分析高手不远矣! © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/third-season/exception.html":{"url":"pages/third-season/exception.html","title":"异常与异常处理","keywords":"","body":"异常与异常处理 exception /ɪkˈsepʃn/ n. 一般情况以外的人(或事物);例外;规则的例外;例外的事物 字面意思：有异于常态，和正常情况不一样，有错误出现。 程序中：阻止当前方法或作用域正常运行的情况，称之为异常。 [!TIP|style:flat|label:Exception异常] 异常指的是在程序运行过程中发生的异常事件，通常是由外部问题（如硬件错误、输入错误）所导致的。在Java等面向对象的编程语言中异常属于对象。 导致的问题： 1、程序得不到正常的运行，不能正常退出 2、导致用户数据丢失 3、程序运行的资源得不到有效的释放 异常处理作用： 1、对异常正确的处理，能将异常提示给编程人员或者是用户 2、使已中断的程序，以适当的方式继续运行或退出，并且可以保存用户的当前操作，或数据回滚 3、最后再把占用的资源释放掉 Throwable类 主要有两个儿子Error与Exception，即Error与Exception类继承Throwable类 Error 错误 [!TIP|style:flat|label:Error] 系统错误，内存溢出 虚拟机错误 VirtualMachineError 线程死锁 ThreadDeath 它的出现，即意味着程序挂了，即程序终结者 好比工厂停水/停电/机器挂了 Exception 异常 [!TIP|style:flat|label:Exception] 编码、环境、用户操作输入出现问题 主要有 RuntimeException 称之为非检查异常 其他异常称之为：检查异常 CheckException 非检查异常 RuntimeException 引起RuntimeException的原因： 1、引用了一个空对象或方法。空指针异常 NullPointerException String str = null; System.out.println(str.length()); 2、数组访问越界。数组下标越界异常 ArrayIndexOutOfBoundsException int[] arr = { 1, 2, 3 } for (int i = 0; i 3、错误的类型转换。类型转换异常 ClassCastException class Animal {} class Dog extends Animal {} class Cat extends Animal {} public class Test { public static void main (String[] args) { Animal a1 = new Dog(); Animal a2 = new Cat(); Dog d1 = (Dog)a1; Dog d2 = (Dog)a2; } } 4、运算异常，整数去整除零。算术异常 ArithmeticException int a = 12; int b = 0; System.out.println(a / b); 5、等等... [!TIP|style:flat|label:RuntimeException] 运行时异常 会由Java虚拟机自动抛出，并自动捕获。 运行时异常的出现，多数情况下说明代码本身出了问题，应该从逻辑上去改进代码。 检查异常 CheckException 比如：文件异常 IOException，SQl异常 SQLException等等很多，需要开发人员自己捕获及处理。 异常处理 try-catch, try-catch-finally 语法 try { // 一些会抛出异常的方法 } catch (Exception e) { // 处理该异常的代码块 } [!WARNING|style:flat|label:如果try抛出异常将会发生什么？] 抛出异常的方法会终止执行！ 程序的控制权将被移交给catch块中的异常处理程序 catch中可以做的事情： 根据业务情况，可以发出一些警告，提示用户或开发人员 也可以记录错误日志等操作等等 try { System.out.print(\"请输入你的年龄：\"); Scanner input = new Scanner(System.in); int age = input.nextInt(); System.out.println(\"The ten years ago, you will\" + (age + 10)); } catch (InputMismatchException e) { System.out.println(\"你应该输入整数！\"); } System.out.println(\"程序结束啦！\"); try会抛出很多种类型的异常，该如何处理？ Scanner input = new Scanner(System.in); try { System.out.print(\"请输入第一个数：\"); int one = input.nextInt(); // input 12 System.out.print(\"请输入第二个数：\"); int tow = input.nextInt(); // input 0 System.out.println(one / tow); } catch (InputMismatchException e) { // 输入不匹配异常 System.out.println(\"你应该输入整数！\"); } catch (ArithmeticException e) { // 英 [əˈrɪθmətɪk] 美 [əˈrɪθmɪtɪk] // 算术异常 System.out.println(\"除数不能为0！\"); } catch (Exception e) { System.out.println(\"不知名异常！\"); } finally { // 最终将要执行的一些代码 } System.out.println(\"程序结束啦！\"); 异常处理注意事项 异常捕获顺序，一定要按先小后大，即先子类再父类： 子类 -> 父类 当异常发生时，异常处理系统会就近寻找匹配的异常处理的catch程序。子类继承于父类，针对于子类的处理程序，父类也是适用的。 善后工作处理 finally 异常发生后，可以使用finally关闭连接，或关闭文件等善后操作。 例子 package com.trycatch.test; public class TryCatchTest { public static void main(String[] args) { // TODO Auto-generated method stub TryCatchTest tc = new TryCatchTest(); int result = tc.test(); System.out.println(\"result: \" + result); } /** * test method * @return */ public int test() { int divider = 10; int result = 0; try { while (divider > -1) { divider--; result += 100 / divider; } return result; } catch (Exception e) { // 打印异常 e.printStackTrace(); System.out.println(\"程序抛出异常了！！\"); return -1; } } } 结果 java.lang.ArithmeticException: / by zero at com.trycatch.test.TryCatchTest.test(TryCatchTest.java:22) at com.trycatch.test.TryCatchTest.main(TryCatchTest.java:8) 程序抛出异常了！！ result: -1 test2 package com.trycatch.test; public class TryCatchTest { public static void main(String[] args) { TryCatchTest tc = new TryCatchTest(); int result2 = tc.test2(); System.out.println(\"test2返回值result为: \" + result2); } /** * test method * @return */ public int test2() { int divider = 10; int result = 0; try { while (divider > -1) { divider--; result += 100 / divider; } return result; } catch (Exception e) { // 打印异常 e.printStackTrace(); System.out.println(\"Test2抛出异常了！！\"); return 999; } finally { System.out.println(\"这是finally！\"); System.out.println(\"Result值为：\" + result); } } } 结果 java.lang.ArithmeticException: / by zero at com.trycatch.test.TryCatchTest.test2(TryCatchTest.java:45) at com.trycatch.test.TryCatchTest.main(TryCatchTest.java:10) Test2抛出异常了！！ 这是finally！ Result值为：281 test2返回值result为: 999 [!TIP|style:flat|label:总结] catch块跟在try语句后面，它可以是一个或多个 catch块有一个参数，该参数是某种异常类的对象 多重catch语句中，异常类型必须子类在前，父类在后 原视频教程出处 https://www.imooc.com/learn/110 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/third-season/throw.html":{"url":"pages/third-season/throw.html","title":"异常抛出及自定义异常","keywords":"","body":"异常抛出及自定义异常 Java中的异常抛出 throw 将产生的异常抛出（动作） throws 声明将要抛出何种类型的异常（声明） public void 方法名(参数列表) throws 异常列表 { // 调用会抛出异常的方法或者： throw new Exception(); } 例子：声明抛出一个异常 public void divide(int one, int two) trhows Exception { if (two == 0) { throw new Exception(\"两数相除，除数不能为0\"); } else { System.out.println(\"两数相除，结果为：\" + one / two); } } 处理1：使用try-catch处理 public void compute () { // do something try { divide(5, 0); } catch (Exception e) { System.out.println(e.getMessage()); } } 处理2：(或)继续抛出异常，让其他更上一层调用程序去处理 public void compute() throws Exception { // do something divide(5, 0); } 自定义异常 class 自定义异常类 extends 异常类型 { // do something } 例子 package com.test public class DrunkException extends Exception { // 自定义一个有参的构造器 public DrunkException(String message) { super(message); } // 因为自定义了构造器，所以编译器不会为我们自动创建一个无参构造器 // 但，有时候我们需要用到无参的构造器，所以再添加一个无参构造器 public DrunkException() { // ... } } Java中的异常链 异常链功能实现，两种实现方法： package com.test public class ChainTest { /** * test1()：抛出\"喝大了\"异常 * test2()：调用test1()，捕获\"喝大了\"异常，并且包装成运行时异常，继续抛出 * main方法中，调用test2()，尝试捕获test2()方法抛出的异常 */ public static void main(String[] args) { ChainTest ct = new ChainTest(); try { ct.test2(); } catch (Exception e) { e.printStack(); } } public void test1 () throws DrunkException { throw new DrunkException(\"喝酒别开车！\"); } public void test2 () { try { test1(); } catch (DrunkException e) { // 包装成运行时异常 RuntimeException newExc = new RuntimeException(\"司机一滴酒，亲人两行泪\"); newExc.initCause(e); throw newExc; } } } 或者 public void test2 () { try { test1(); } catch (DrunkException e) { // 包装成运行时异常 RuntimeException newExc = new RuntimeException(e); throw newExc; } } [!TIP|style:flat|label:总结] Exception的父类是Throwable 使用try-catch-finally语句捕获并处理异常 可以使用throw语句抛出异常 实际应用中的经验与总结 1、处理运行时异常时，采用逻辑去和里规避同时辅助try-catch处理 2、在多重catch块后面，可以加一个catch（Exception）来处理可能会被遗漏的异常 3、对于不确定的代码，也可以加上try-catch，处理潜在的异常 4、尽量去处理异常，切忌只是简单的调用printStackTrace()去打印输出 5、具体如何处理异常，要根据不同的业务需求和异常类型去决定 6、尽量添加finally语句块去释放占用的资源，尤其是在有网络连接或有数据库操作的情况下等等。 练习题 要求： 1、定义字符串数组保存图书信息 2、提示用户输入，分别按\"书名\"和\"图书序号\"查找图书 3、根据输入信息进行适当的异常处理 a、如果输入类型错误，抛出\"错误命令异常\"，并提示重新输入 b、如果书名不存在，抛出\"图书不存在异常\"，并提示重新输入 c、如果图书序号超过字符串数组范围，抛出\"图书不存在异常\"，并提示重新输入 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/third-season/string.html":{"url":"pages/third-season/string.html","title":"字符串","keywords":"","body":"字符串 在 Java 中，字符串被作为 String 类型的对象处理。 String 类位于 java.lang 包中。默认情况下，该包被自动导入所有的程序。 创建String对象的方法 创建一个字符串对象\"Hello World\"，变量名为str String str = \"Hello World\"; 创建一个空字符串对象 String str = new String(); 创建一个字符串对象 String str = new String(\"Hello World\"); 字符串的不变性 String 对象创建后则 不能被修改，是不可变的。所谓的修改其实是创建了新的对象，所指向的内存空间不同。 String str1 = \"Hello World\"; String str2 = \"Hello World\"; String Str3 = new String(\"Hello World\"); String Str4 = new String(\"Hello World\"); // 多次出现的字符串常量，Java编译程序只创建一个，所以返回true System.out.println(str1 == str2); // str1和str3是不同的对象，所以返回false System.out.println(str1 == str3); // str3和str4是不同的对象，所以返回false System.out.println(str3 == str4); str1 = \"Wolcome to \" + str1; // 字符串str1被修改，指向新的内存空间 System.out.println(str1); [!TIP|style:flat|label:总结] 在第一次使用字符串引用的使用，也是通过new来创建字符串的，只是隐式的new一个字符串对象 在你第二次使用同一个字符串的时候，会查找堆内存中有没有和该字符串一样的，如果有就直接引用这个堆中已经有的字符串对象，如果没有，还是会new一个； 而直接使用new的方法，创建字符串，是不管堆中有没有，直接创建一个新的对象，所以在比较的时候，都是false 关系图说明： 1、通过 String str1 = \"Hello World\"; 声明了一个字符串对象， str1 存放了到字符串对象的引用。 然后通过 str1 = \"Wolcome to \" + str1; 改变了字符串 str1 ，其实质是创建了新的字符串对象，变量 str1 指向了新创建的字符串对象。 2、一旦一个字符串在内存中创建，则这个字符串将不可改变。如果需要一个可以改变的字符串，我们可以使用StringBuffer或者StringBuilder。 3、每次 new 一个字符串就是产生一个新的对象，即便两个字符串的内容相同，使用 == 比较时也为 false ,如果只需比较内容是否相同，应使用 equals() 方法。 String 类的常用方法 package com.string; import java.util.Arrays; public class StrTest { public static void main(String[] args) { String str = \"Hello World\"; System.out.println(\"length(): \" + str.length()); // find char W char w = 'W'; System.out.println(\"indexOf('W'): \" + str.indexOf(w)); // split array String[] arr = str.split(\" \"); System.out.print(\"Arrays.toString(): \" + Arrays.toString(arr)); System.out.println(); // get children string by index[3, 7) System.out.println(\"get the substring of index[3, 7), with substring(): \" + str.substring(3, 7)); // System.out.println(\"toLowerCase(): \" + str.toLowerCase()); System.out.println(\"toUpperCase(): \" + str.toUpperCase()); System.out.println(\"charAt(1): \" + str.charAt(1)); // to byte[] byte[] b = str.getBytes(); System.out.print(\"to bytes: \"); for (int i = 0; i 运行结果： length(): 11 indexOf('W'): 6 Arrays.toString(): [Hello, World] get the substring of index[3, 7), with substring(): lo W toLowerCase(): hello world toUpperCase(): HELLO WORLD charAt(1): e to bytes: 72 101 108 108 111 32 87 111 114 108 100 Are str and str2 memory addresses the same? false Is Str the same as str2? true [!TIP|style:flat|label:总结] 1、字符串 str 中字符的索引从0开始，范围为 0 到 str.length()-1 2、使用 indexOf 进行字符或字符串查找时，如果匹配返回位置索引；如果没有匹配结果，返回 -1 3、使用 substring(beginIndex , endIndex) 进行字符串截取时，包括 beginIndex 位置的字符，不包括 endIndex 位置的字符 “==” 和 equals() 有什么区别呢？ == : 判断两个字符串在内存中首地址是否相同，即判断是否是同一个字符串对象 equals() : 比较存储在两个字符串对象中的内容是否一致 package com.string; public class CNStrTest { public static void main(String[] args) { String str = \"String类常用方法。\"; try { byte[] b = str.getBytes(\"GBK\"); for (int i = 0; i 运行结果： 83 116 114 105 110 103 -64 -32 -77 -93 -45 -61 -73 -67 -73 -88 -95 -93 [!TIP|style:flat|label:PS] 字节是计算机存储信息的基本单位，1 个字节等于 8 位， gbk 编码中 1 个汉字字符存储需要 2 个字节，1 个英文字符存储需要 1 个字节。 所以我们看到上面的程序运行结果中，每个汉字对应两个字节值，如“类”对应 “-64 -32 ” ，而英文字母 “S” 对应 “83” 。 同时，我们还发现汉字对应的字节值为负数，原因在于每个字节是 8 位，最大值不能超过 127，而汉字转换为字节后超过 127，如果超过就会溢出，以负数的形式显示。 在java中，一个英文字符占多少字节，一个中文字符占多少字节？ by 慕课网友：Yesabella [!WARNING|style:flat|label:字节补充] Java采用unicode来表示字符，java中的一个char是2个字节，一个中文或英文字符的unicode编码都占2个字节，但如果采用其他编码方式，一个字符占用的字节数则各不相同。 在 GB 2312 编码或 GBK 编码中，一个英文字母字符存储需要1个字节，一个汉子字符存储需要2个字节。 在UTF-8编码中，一个英文字母字符存储需要1个字节，一个汉字字符储存需要3到4个字节。 在UTF-16编码中，一个英文字母字符存储需要2个字节，一个汉字字符储存需要3到4个字节（Unicode扩展区的一些汉字存储需要4个字节）。 在UTF-32编码中，世界上任何字符的存储都需要4个字节。 如果编码方式为GBK，对于字符串“测试test”，字符长度为6，字节长度为8。 如果编码方式为UTF_8，对于字符串“测试test”，字符长度为6，字节长度为10。 String aa = \"学\"; System.out.println(\"UTF-8编码长度:\"+aa.getBytes(\"UTF-8\").length); System.out.println(\"GBK编码长度:\"+aa.getBytes(\"GBK\").length); System.out.println(\"GB2312编码长度:\"+aa.getBytes(\"GB2312\").length); // 运行结果 // UTF-8编码长度:3 // GBK编码长度:2 // GB2312编码长度:2 练习 public class HelloWorld { public static void main(String[] args) { // 定义一个字符串 String s = \"aljlkdsflkjsadjfklhasdkjlflkajdflwoiudsafhaasdasd\"; // 出现次数 int num = 0; // 循环遍历每个字符，判断是否是字符 a ，如果是，累加次数 for ( int i = 0; i StringBuilder 类 在Java中，除了可以使用 String 类来存储字符串，还可以使用 StringBuilder 类或 StringBuffer 类存储字符串，那么它们之间有什么区别呢？ String str = \"Hello\"; System.out.println(str + \" World\"); System.out.println(str); 结果 Hello World Hello 从运行结果中我们可以看到，程序运行时会额外创建一个对象，保存 \"Hello World\"。当频繁操作字符串时，就会额外产生很多临时变量。 使用 StringBuilder 或 StringBuffer 就可以避免这个问题。 [!TIP|style:flat|label:StringBuilder和StringBuffer] 它们基本相似，不同之处，StringBuffer 是 线程安全的，而 StringBuilder 则没有实现线程安全功能，所以性能略高。 因此一般情况下，如果需要创建一个内容可变的字符串对象，应优先考虑使用 StringBuilder 类。 定义 // 创建一个StringBuilder对象 StringBuilder str1 = new StringBuilder(); // 创建一个字符串\"Hello World\" StringBuilder str2 = new StringBuilder(\"Hello World\"); System.out.println(str2); 常用方法 方法 说明 StringBuilder append(参数) 追加内容到当前StringBuilder对象的末尾 StringBuilder insert(位置, 参数) 将内容插入到StringBuilder对象的指定位置 String toString() 将StringBuilder对象转换为String对象 int length() 获取字符串的长度 练习：将一个由英文字母组成的字符串转换成指定格式---从右边开始每三个字母用逗号分隔的形式。 package com.string; public class StringBuilderTest { public static void main(String[] args) { // 创建一个空的StringBuilder对象 StringBuilder str = new StringBuilder(); // 追加字符串 str.append(\"jaewkjldfxmopzdm\"); // 从后往前每隔三位插入逗号 for (int i = str.length() - 1, j = 0; i >= 0; i--, j++) { if (j > 0 && j % 3 == 2) { str.insert(i, \",\"); } } // 将StringBuilder对象转换为String对象并输出 System.out.print(str.toString()); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/third-season/thread-safe.html":{"url":"pages/third-season/thread-safe.html","title":"thread-safe 线程安全","keywords":"","body":"thread-safe 线程安全 线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。 百度百科 实现线程安全的三种方式 转自：https://www.cnblogs.com/lizhangyong/p/8029287.html 一个程序在运行起来的时候会转换成进程，通常含有多个线程。 通常情况下，一个进程中的比较耗时的操作（如长循环、文件上传下载、网络资源获取等），往往会采用多线程来解决。 比如显示生活中，银行取钱问题、火车票多个售票窗口的问题，通常会涉及到并发的问题，从而需要多线程的技术。 当进程中有多个并发线程进入一个重要数据的代码块时，在修改数据的过程中，很有可能引发线程安全问题，从而造成数据异常。例如，正常逻辑下，同一个编号的火车票只能售出一次，却由于线程安全问题而被多次售出，从而引起实际业务异常。 [!TIP|style:flat|label:示例] 现在我们就以售票问题来演示线程安全的问题。 在不对多线程数据进行保护的情况下会引发的状况 public class ThreadUnSecurity { static int tickets = 10; class SellTickets implements Runnable { @Override public void run() { // 未加同步时产生脏数据 while(tickets > 0) { System.out.println(Thread.currentThread().getName() + \"--->售出第：\" + tickets + \"票\"); tickets--; try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } if (tickets 售票结束！\"); } } } public static void main(String[] args) { SellTickets sell = new ThreadUnSecurity().new SellTickets(); Thread thread1 = new Thread(sell, \"1号窗口\"); Thread thread2 = new Thread(sell, \"2号窗口\"); Thread thread3 = new Thread(sell, \"3号窗口\"); Thread thread4 = new Thread(sell, \"4号窗口\"); thread1.start(); thread2.start(); thread3.start(); thread4.start(); } } 运行结果： 1号窗口--->售出第：10票 2号窗口--->售出第：10票 3号窗口--->售出第：8票 4号窗口--->售出第：7票 3号窗口--->售出第：6票 4号窗口--->售出第：6票 1号窗口--->售出第：6票 2号窗口--->售出第：6票 3号窗口--->售出第：2票 1号窗口--->售出第：2票 2号窗口--->售出第：2票 4号窗口--->售出第：2票 4号窗口--->售票结束！ 3号窗口--->售票结束！ 2号窗口--->售票结束！ 1号窗口--->售票结束！ 我们可以看出同一张票在不对票数进行保护时会出现同一张票会被出售多次！由于线程调度中的不确定性，读者在演示上述代码时，出现的运行结果会有不同。 为了解决上述脏数据的问题，我为大家介绍3种使用比较普遍的三种同步方式。 第一种实现线程安全的方式: 同步代码块 synchronized 英[ˈsɪŋkrənaɪzd] 美[ˈsɪŋkrənaɪzd] v. (使)同步，在时间上一致，同速进行 synchronize的过去分词和过去式 synchronize 英 [ˈsɪŋkrənaɪz] 美 [ˈsɪŋkrənaɪz] v.(使)同步，在时间上一致，同速进行 第三人称单数： synchronizes 现在分词： synchronizing 过去式： synchronized 过去分词： synchronized 派生词： synchronization-isation n. 有synchronized关键字修饰的语句块，即为同步代码块。同步代码块会被JVM自动加上内置锁，从而实现同步。 public class ThreadSynchronizedSecurity { static int tickets = 10; class SellTickets implements Runnable { @Override public void run() { // 同步代码块 while(tickets > 0) { synchronized (this) { // System.out.println(this.getClass().getName().toString()); if (tickets 售出第：\" + tickets + \" 票\"); tickets--; try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } if (tickets 售票结束！\"); } } } } public static void main(String[] args) { SellTickets sell = new ThreadSynchronizedSecurity().new SellTickets(); Thread thread1 = new Thread(sell, \"1号窗口\"); Thread thread2 = new Thread(sell, \"2号窗口\"); Thread thread3 = new Thread(sell, \"3号窗口\"); Thread thread4 = new Thread(sell, \"4号窗口\"); thread1.start(); thread2.start(); thread3.start(); thread4.start(); } } 输出结果读者可自行调试，不会出现同一张票被出售多次的情况。 第二种实现线程安全的方式: 同步方法 即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。 public class ThreadSynchronizedMethodSecurity { static int tickets = 10; class SellTickets implements Runnable{ @Override public void run() { // 同步方法 while (tickets > 0) { synMethod(); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } if (tickets售票结束\"); } } } synchronized void synMethod() { synchronized (this) { if (tickets 售出第 \" + tickets + \" 票 \"); tickets--; } } } public static void main(String[] args) { SellTickets sell = new ThreadSynchronizedMethodSecurity().new SellTickets(); Thread thread1 = new Thread(sell, \"1号窗口\"); Thread thread2 = new Thread(sell, \"2号窗口\"); Thread thread3 = new Thread(sell, \"3号窗口\"); Thread thread4 = new Thread(sell, \"4号窗口\"); thread1.start(); thread2.start(); thread3.start(); thread4.start(); } } 读者可自行调试上述代码的运行结果。 第三种实现线程安全的方式: Lock锁机制 通过创建Lock对象，采用lock()加锁，unlock()解锁，来保护指定的代码块。 import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class ThreadLockSecurity { static int tickets = 10; class SellTickets implements Runnable{ Lock lock = new ReentrantLock(); @Override public void run() { // Lock锁机制 while(tickets > 0) { try { lock.lock(); if (tickets 售出第： \"+tickets+\" 票\"); tickets--; } catch (Exception e1) { // TODO Auto-generated catch block e1.printStackTrace(); } finally { lock.unlock(); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } if (tickets 售票结束！\"); } } } public static void main(String[] args) { SellTickets sell = new ThreadLockSecurity().new SellTickets(); Thread thread1 = new Thread(sell, \"1号窗口\"); Thread thread2 = new Thread(sell, \"2号窗口\"); Thread thread3 = new Thread(sell, \"3号窗口\"); Thread thread4 = new Thread(sell, \"4号窗口\"); thread1.start(); thread2.start(); thread3.start(); thread4.start(); } } [!TIP|style:flat|label:总结] 由于synchronized是在JVM层面实现的，因此系统可以监控锁的释放与否； 而ReentrantLock是使用代码实现的，系统无法自动释放锁，需要在代码中的finally子句中显式释放锁lock.unlock()。 另外，在并发量比较小的情况下，使用synchronized是个不错的选择；但是在并发量比较高的情况下，其性能下降会很严重，此时ReentrantLock是个不错的方案。 补充：　　 在使用synchronized 代码块时,可以与wait()、notify()、notifyAll()一起使用，从而进一步实现线程的通信。 其中，wait()方法会释放占有的对象锁，当前线程进入等待池，释放cpu，而其他正在等待的线程即可抢占此锁，获得锁的线程即可运行程序； 线程的sleep()方法则表示，当前线程会休眠一段时间，休眠期间，会暂时释放cpu，但并不释放对象锁。也就是说，在休眠期间，其他线程依然无法进入被同步保护的代码内部，当前线程休眠结束时，会重新获得cpu执行权，从而执行被同步保护的代码。 wait()和sleep()最大的不同在于wait()会释放对象锁，而sleep()不会释放对象锁。 notify()方法会唤醒因为调用对象的wait()而处于等待状态的线程，从而使得该线程有机会获取对象锁。调用notify()后，当前线程并不会立即释放锁，而是继续执行当前代码，直到synchronized中的代码全部执行完毕，才会释放对象锁。JVM会在等待的线程中调度一个线程去获得对象锁，执行代码。 需要注意的是，wait()和notify()必须在synchronized代码块中调用。 notifyAll()是唤醒所有等待的线程。 接下来，我们通过下一个程序，使得两个线程交替打印“A”和“B”各10次。请见下述代码： public class ThreadDemo { static final Object obj = new Object(); //第一个子线程 static class ThreadA implements Runnable{ @Override public void run() { int count = 10; while(count > 0) { synchronized (ThreadDemo.obj) { System.out.println(\"A-----\" + count); count--; synchronized (ThreadDemo.obj) { //notify()方法会唤醒因为调用对象的wait()而处于等待状态的线程，从而使得该线程有机会获取对象锁。 //调用notify()后，当前线程并不会立即释放锁，而是继续执行当前代码，直到synchronized中的代码全部执行完毕， ThreadDemo.obj.notify(); try { ThreadDemo.obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } } static class ThreadB implements Runnable{ @Override public void run() { int count = 10; while(count > 0) { synchronized (ThreadDemo.obj) { System.out.println(\"B-----\" + count); count--; synchronized (ThreadDemo.obj) { //notify()方法会唤醒因为调用对象的wait()而处于等待状态的线程，从而使得该线程有机会获取对象锁。 //调用notify()后，当前线程并不会立即释放锁，而是继续执行当前代码，直到synchronized中的代码全部执行完毕， ThreadDemo.obj.notify(); try { ThreadDemo.obj.wait(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } } } public static void main(String[] args) { new Thread(new ThreadA()).start(); new Thread(new ThreadB()).start(); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/third-season/wrapper-class.html":{"url":"pages/third-season/wrapper-class.html","title":"包装类","keywords":"","body":"包装类 基本数据类型(int、float、double、boolean、char等)是不具备对象的特性的。比如不能调用方法、功能简单。 为了使基本数据类型也 具备对象的特性， Java 为每个基本数据类型都提供了一个 包装类，这样我们就可以像操作对象那样来操作基本数据类型。 基本类型和包装类之间的对应关系： 基本类型 对应的包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 包装类主要提供了两大类方法： 1、将本类型和其他基本类型进行转换的方法。 2、将字符串和本类型及包装类互相转换的方法。 以 Integer 包装类为例，来看下包装类的特性。 Integer 包装类的构造方法： Integer(int value) 创建一个Integer对象，表示指定的int值 Integer(String s) 创建一个Integer对象，表示String参数所指示的int值 int i = 2; // 定义Integer包装类对象，值为5 Integer m = new Integer(5); // 定义Integer包装类对象，值为8 Integer n = new Integer(\"8\"); Integer包装类的常用方法： 方法名 返回值 说明 byteValue() byte 将Integer转为byte类型 doubleValue() double 转为double类型 floatValue() float 转为float类型 intValue() int 转为int类型 longValue() long 转为long类型 parseInt(String s) static int 将字符串转为int类型 toString() String 转为字符串类型 valueOf(String s) static Integer 将字符串转换为Integer类型 public class WrapperClass { public static void main(String[] args) { int i = 2; Integer m = new Integer(5); Integer n = new Integer(\"8\"); System.out.println(i); System.out.println(m); System.out.println(n); // 定义int类型变量，值为86 int score1 = 86; // 创建Integer包装类对象，表示变量score1的值 Integer score2 = new Integer(score1); // 将Integer包装类转换为double类型 double score3 = score2.doubleValue(); // 将Integer包装类转换为float类型 float score4 = score2.floatValue(); // 将Integer包装类转换为int类型 int score5 = score2.intValue(); System.out.println(\"Integer包装类：\" + score2); System.out.println(\"double类型：\" + score3); System.out.println(\"float类型：\" + score4); System.out.println(\"int类型：\" + score5); } } 运行结果： 2 5 8 Integer包装类：86 double类型：86.0 float类型：86.0 int类型：86 基本类型和包装类之间的转换 基本类型和包装类之间经常需要互相转换，以 Integer 为例（其他几个包装类的操作与此雷同）： // 定义Integer包装类对象，值为3 Integer a = new Integer(3); // 将对象和基本类型进行运算 int b = a + 5; 在 JDK1.5 引入自动装箱和拆箱的机制后，包装类和基本类型之间的转换就更加轻松便利了。 那什么是装箱和拆箱呢？我们分别来看下 装箱：把基本类型转换成包装类，使其具有对象的性质，又可分为手动装箱和自动装箱 // 定义一个int类型值 int i = 10; // 手动装箱 Integer x = new Integer(i); // 自动装箱 Integer y = i; 拆箱：和装箱相反，把包装类对象转换成基本类型的值，又可分为手动拆箱和自动拆箱 // 定义一个Integer包装类对象，值为8 Integer j = new Integer(8); // 手动拆箱为int类型 int m = j.intValue(); // 自动拆箱为int类型 int n = j; [!TIP|style:flat|label:总结] Integer 类型可以自动转化为 int 基本类型 int 类型对应的包装类是 java.lang.Integer long 类型可以自动转化为 Long类型 基本类型和字符串之间的转换 在程序开发中，我们经常需要在基本数据类型和字符串之间进行转换。 其中，基本类型转换为字符串有三种方法： 1、使用包装类的 toString() 方法 2、使用String类的 valueOf() 方法 3、用一个空字符串加上基本类型，得到的就是基本类型数据对应的字符串 // 将基本类型转化为字符串 int c = 10; String str1 = Integer.toString(c); String str2 = String.valueOf(c); String str3 = c + \"\"; 再来看，将字符串转换成基本类型有两种方法： 1、调用包装类的 parseXxx 静态方法 2、调用包装类的 valueOf() 方法转换为基本类型的包装类，会自动拆箱 // 将字符串转化为基本类型 String str = \"8\"; int d = Integer.parseInt(str); int e = Integer.valueOf(str); PS：其他基本类型与字符串的相互转化这里不再一一列出，方法都类似。 [!TIP|style:flat|label:总结] 每一个基本数据类型，都对应一个包装类 包装类都在 java.lang 包中 包装类提供了在不同类型间进行转换的方法 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/third-season/date.html":{"url":"pages/third-season/date.html","title":"Date和SimpleDateFormat类","keywords":"","body":"Date 和 SimpleDateFormat 类 Date类 java.util 包中的 Date 类，这个类最主要的作用就是获取当前时间。 // 使用默认的构造方法创建Date对象 Date d = new Date(); // 输出Date对象 System.out.println(d); 使用 Date 类的默认无参构造方法创建出的对象就代表当前时间。 Mon Apr 08 22:34:51 CST 2019 其中， Mon 代表 Monday (星期一)， Apr 代表 April (四月)， 08 代表 08 号， CST 代表 China Standard Time (中国标准时间，也就是北京时间，东八区)。 SimpleDateFormat类 java.text 包中的 SimpleDateFormat类 1、使用 format() 方法将日期转换为指定格式的文本 import java.util.*; import java.text.*; public class DateTest { public static void main(String[] args) { // 创建Date对象，表示当前时间 Date d = new Date(); // 创建SimpleDateFormat对象，指定目标格式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); // 调用format()方法，格式化时间，转化为指定格式字符串 String today = sdf.format(d); // 输出转换后的字符串 System.out.print(today); } } 代码中的 “yyyy-MM-dd HH:mm:ss” 为预定义字符串， yyyy 表示四位年， MM 表示两位月份， dd 表示两位日期， HH 表示小时(使用24小时制)， mm 表示分钟， ss 表示秒，这样就指定了转换的目标格式，最后调用 format() 方法将时间转换为指定的格式的字符串。 运行结果： 2019-04-08 22:41:48 2、使用 parse() 方法将文本转换为日期 import java.util.Date; import java.text.ParseException; import java.text.SimpleDateFormat; public class DateParseTest { public static void main(String[] args) { // 创建日期格式的字符串 String day = \"2019年04月08日 22:44:23\"; // 创建SimpleDateFormat对象，指定字符串的日期格式 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); // 调用parse()方法，将字符串转化为日期 try { Date date = sdf.parse(day); // 输出转换后的时间 System.out.println(\"parse后的时间：\" + date); } catch (ParseException e) { e.printStackTrace(); System.out.println(\"parse(\" + day + \")失败\"); } } } 代码中的 “yyyy年MM月dd日 HH:mm:ss” 指定了字符串的日期格式，调用 parse() 方法将文本转换为日期。 运行结果： parse后的时间：Mon Apr 08 22:44:23 CST 2019 [!WARNING|style:flat|label:注意] 调用 SimpleDateFormat 对象的 parse() 方法时可能会出现转换异常，即 ParseException ，因此需要进行异常处理 使用 Date 类时需要导入 java.util 包，使用 SimpleDateFormat 时需要导入 java.text 包 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/third-season/calendar.html":{"url":"pages/third-season/calendar.html","title":"Calendar类的应用","keywords":"","body":"Calendar类 Date 类最主要的作用就是获得当前时间，同时这个类里面也具有设置时间以及一些其他的功能，但是由于本身设计的问题，这些方法却遭到众多批评，不建议使用，更推荐使用 Calendar 类进行时间和日期的处理。 java.util.Calendar 类是一个抽象类，可以通过调用 getInstance() 静态方法获取一个 Calendar 对象，此对象已由当前日期时间初始化，即默认代表当前时间，如 Calendar c = Calendar.getInstance(); 那么如何使用 Calendar 获取年、月、日、时间等信息呢？我们来看下面的代码： import java.util.Calendar; public class CalenderTest { public static void main(String[] args) { // 创建Canlendar对象 Calendar c = Calendar.getInstance(); int year = c.get(Calendar.YEAR); int month = c.get(Calendar.MONTH) + 1; int day = c.get(Calendar.DAY_OF_MONTH); int hour = c.get(Calendar.HOUR_OF_DAY); int minute = c.get(Calendar.MINUTE); int second = c.get(Calendar.SECOND); System.out.println(\"Current time: \" + year + \"-\" + month + \"-\" + day + \" \" + hour + \":\" + minute + \":\" + second); } } 其中，调用 Calendar 类的 getInstance() 方法获取一个实例，然后通过调用 get() 方法获取日期时间信息，参数为需要获得的字段的值， Calendar.YEAR 等为 Calendar 类中定义的静态常量。 运行结果： Current time: 2019-4-8 23:5:14 Calendar 类提供了 getTime() 方法，用来获取 Date 对象，完成 Calendar 和 Date 的转换，还可通过 getTimeInMillis() 方法，获取此 Calendar 的时间值，以毫秒为单位。如下所示： // 将Calendar对象转化为Date对象 Date date = c.getTime(); // 获取当前毫秒数 Long msec = c.getTimeInMillis(); System.out.println(\"Current time: \" + date); System.out.println(\"Current millis: \" + msec); 运行结果： Current time: Mon Apr 08 23:10:08 CST 2019 Current millis: 1554736208939 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/third-season/math.html":{"url":"pages/third-season/math.html","title":"Math类","keywords":"","body":"Math类 Math 类位于 java.lang 包中，包含用于执行基本数学运算的方法， Math 类的所有方法都是静态方法，所以使用该类中的方法时，可以直接使用类名.方法名，如： Math.round(); 方法名 返回值 说明 round() long 返回四舍五入后的整数 floor() double 返回小于参数的最大整数 ceil() double 返回大于参数的最小整数 random() double 返回[0, 1)之间的随机浮点数 public class MathTest { public static void main(String[] args) { double a = 23.92; int b = (int) a; System.out.println(a +\"强制int类型转换：\" + b); long c = Math.round(a); System.out.println(\"round(\"+ a +\")四舍五入：\" + c); double d = Math.floor(a); System.out.println(\"floor(\"+ a +\")：\" + d); double e = Math.ceil(a); System.out.println(\"ceil(\"+ a +\")：\" + e); double f = Math.random(); System.out.println(\"random()：\" + f); } } 运行结果： 23.92强制int类型转换：23 round(23.92)四舍五入：24 floor(23.92)：23.0 ceil(23.92)：24.0 random()：0.5485492457892083 [!TIP|style:flat|label:PS] Math 类还提供了许多其他方法，各位小伙伴们可以注意关注 wiki ，查阅更多信息。 练习 public class MathTest2 { public static void main(String[] args) { // 定义一个整型数组，长度为10 int[] nums = new int[10]; // 通过循环给数组赋值 for (int i = 0; i © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/third-season/collection-map.html":{"url":"pages/third-season/collection-map.html","title":"集合框架Collection、Map","keywords":"","body":"Java中的集合框架 集合的概念 现实生活中：把很多的事物凑在一起。比如购物车是商品的集合，军队是军人的集合等。 数学中的集合：具有共同属性的事物的总体。比如有理数，整数等。 Java中的集合类：是一种工具类，就像是容器，储存任意数量的具有共同属性的对象。 集合的作用 在类的内部，对数据进行组织； 简单而快捷的搜索大数量的条目； 有的集合接口，提供了一系列排列有序的元素，并且可以在序列中间快速的插入或者删除有关元素。 有的集合接口，提供了映射关系，可以通过关键字key去快速查找到对应的唯一对象，而这个关键字可以是任意类型。 与数组对比 数组长度固定，当元素个数超出数组长度时，需要重新创建新数组，再\"转移\"数据。 集合：长度可以根据数据数量自动改变。 [!TIP|style:flat|label:总结] 数组的长度固定，集合长度可变。 数组只能通过下标访问元素，类型固定，查找数据需要逐个遍历。而有的集合可以通过任意类型查找所映射的具体对象。 Java集合框架体系结构 主要由两大家族（两个根接口）组成：Collection、Map Collection子接口：List、Queue、Set List（序列）、Queue（队列）：元素排列有序，且可以重复。 Set（集）：元素无序，且不可重复。 List与Set较为常用。 List中一个很重要的实现类ArrayList（数组序列）。 Queue中一个重要的实现类LinkedList（链表），同时也是List的实现类。 Set中一个重要的实现类HashSet（哈希集）。 Map Map也有很多子接口。 Map中一个很重要的实现类：HashMap（哈希表）。 [!TIP|style:flat|label:数据存储] Collection中存储一个个独立的对象。 Map内以Key、Value键值对形式存储数据，即一个Entry（键值对，Map的内部类）类的实例。Key、Value可以是任意类型的对象。 Collection可以想象为单身宿舍，里面存储的一个一个的光棍。 Map内存储的一对一对的夫妇。 Collection接口、子接口以及实现类 Collection接口 是List、Set和Queue接口的父接口。 定义了可用于操作List、Set、Queue的方法：增删改查。 List接口及其实现类：ArrayList List是元素有序，并且可以重复的集合，被称为序列。 List可以精确的控制每个元素的插入位置，或删除某个指定位置元素。 ArrayList：数组序列，是List的一个重要实现类。 ArrayList底层是由数组实现的。 // List接口 import java.util.List; [!NOTE|label:练习-模拟学生选课功能] 选择课程（往集合中添加课程） 删除所选的某门课程（删除集合中的元素） 查看所选课程 修改所选课程 Course.java public class Course { public int id; public String name; public Course (int id, String name) { this.id = id; this.name = name; } } CourseStorage.java import java.util.List; import java.util.ArrayList; import java.util.Arrays; import java.util.Iterator; /** * 备选课程库 * @author capricorncd */ public class CourseStorage { // 用于存放课程的List public List coursesToSelect; // constructor public CourseStorage () { // 初始化coursesToSelect属性 // List是一个接口类，不能直接实例化， // 所以使用实现类ArrayList this.coursesToSelect = new ArrayList(); } /** * System.out.println * @param str */ public static void print (String str) { System.out.println(str); } /** * System.out.println * @param type 1成功，0失败 * @param str */ public static void print (int type, String str) { System.out.println((type == 1 ? \"Success in \" : \"Failure to \") + str); } /** * 往coursesToSelect中添加课程 * @param id * @param name */ public void addCourse (int id, String name) { try { // 创建一个课程对象 Course cr = new Course(id, name); // 调用add方法，添加到备选课程List中 coursesToSelect.add(cr); print(1, \"addCourse(int id, String name): \" + id + \"=>\" + name); } catch (Exception e) { print(0, \"addCourse(int id, String name): \" + id + \"=>\" + name); } } /** * 往coursesToSelect中指定位置添加课程 * @param index 索引 * @param id 课程id * @param name 课程名称 */ public void addCourse (int index, int id, String name) { try { // 创建一个课程对象 Course cr = new Course(id, name); // 调用add方法，添加到备选课程List中 coursesToSelect.add(index, cr); Course temp = (Course) coursesToSelect.get(index); print(1, \"addCourse(int index, int id, String name): \" + temp.id + \"=>\" + temp.name); } catch (Exception e) { e.printStackTrace(); print(0, \"addCourse(int index, int id, String name): \" + id + \"=>\" + name); } } /** * 往coursesToSelect中批量添加课程 * @param courses 课程对象数组 */ public void addCourses (Course[] courses) { try { coursesToSelect.addAll(Arrays.asList(courses)); for (Course cr : courses) { print(1, \"addCourses(Course[] courses): \" + cr.id + \"=>\" + cr.name); } } catch (Exception e) { print(0, \"addCourses (Course[] courses): \" + courses.toString()); } } /** * 往coursesToSelect中指定位置开始批量添加课程 * @param index * @param courses */ public void addCourses (int index, Course[] courses) { try { // Arrays.asList() 将数组转换为一个集合 coursesToSelect.addAll(index, Arrays.asList(courses)); for (Course cr : courses) { print(1, \"addCourses(int index, Course[] courses): \" + cr.id + \"=>\" + cr.name); } } catch (Exception e) { e.printStackTrace(); print(0, \"addCourses (int index, Course[] courses): \" + courses.toString()); } } /** * 打印coursesToSelect */ public void printAllCourses () { print(\"-------------- 华丽的分割线 printAllCourses ---------------\"); int size = coursesToSelect.size(); Course cr; for (int i = 0; i 删除成功！\"); testForEach(); } catch (IndexOutOfBoundsException e) { e.printStackTrace(); print(\"=> 删除失败，索引为\" + i + \"的课程不存在！\"); } } /** * 批量删除课程 * @param arr */ public void testRemoveAll (Course[] arr) { try { coursesToSelect.removeAll(Arrays.asList(arr)); print(\"批量删除课程成功！\"); testForEach(); } catch (Exception e) { e.printStackTrace(); print(\"批量删除课程失败！\"); } } public static void main(String[] args) { CourseStorage cs = new CourseStorage(); // 添加课程 cs.addCourse(1, \"数据结构\"); cs.addCourse(0, 2, \"C语言\"); // 批量添加课程 Course[] courses = { new Course(3, \"离散数学\"), new Course(4, \"汇编语言\") }; cs.addCourses(courses); Course[] courses2 = { new Course(5, \"高等数学\"), new Course(6, \"GoLang\") }; cs.addCourses(2, courses2); // 打印所有元素 cs.printAllCourses(); // 重复添加 cs.addCourse(1, \"数据结构\"); // 打印或遍历所有元素 // cs.printAllCourses(); // cs.testItetator(); cs.testForEach(); // 修改元素 int modifyIndex = cs.coursesToSelect.size() - 1; cs.testModify(modifyIndex, new Course(7, \"JavaScript\")); cs.testItetator(); // 删除元素 // cs.testRemove(6); Course[] removeAllItems = { (Course) cs.coursesToSelect.get(4), (Course) cs.coursesToSelect.get(5) }; cs.testRemoveAll(removeAllItems); } } 代码 https://github.com/capricorncd/Java-Notes/tree/master/codes/collection-and-map/src/com/test/collection © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/third-season/generic.html":{"url":"pages/third-season/generic.html","title":"泛型","keywords":"","body":"泛型 集合中的元素，可以是任意类型的对象（对象的引用）。 如果把某个对象放入集合，则会忽略他的类型，而把他当作Object处理。 泛型 [!TIP|style:flat|label:什么是泛型] 泛型是jdk5引入的类型机制，就是将类型参数化，它是早在1999年就制定的jsr14的实现。 泛型机制将类型转换时的类型检查从运行时提前到了编译时。比杂乱得使用Object，并在需要时再 强制类型转换的机制 具有更好的可读性和安全性。 泛型程序设计意味着程序可以被不同类型的对象重用，类似c++的模版。 泛型对于集合类尤其有用，如ArrayList。这里可能有疑问，既然泛型为了适应不同的对象，ArrayList本来就可以操作不同类型的对象呀？那是因为没有泛型之前采用继承机制实现的，实际上它只维护了一个Object对象的数组。结果就是对List来说它只操作了一类对象Object，而在用户看来却可以保存不同的对象。 泛型则是规定了某个集合，只可以存放特定类型的对象。 会在编译期间进行类型检查。 可以直接按指定类型获取集合元素，即无需使用Object对象取出，再做类型转换。 import java.util.ArrayList; import java.util.List; public class TestGeneric { // 带有泛型Course的List类型属性 public List courses; // 构造器 public TestGeneric() { this.courses = new ArrayList(); } public void testAdd() { Course cr1 = new Course(1, \"世界地理\"); courses.add(cr1); // 泛型集合中，不能添加泛型规定的类型以外的对象，否则会报错！ // [WARNING:The method add(Course) in the type List is not applicable for the arguments (Strring)] // courses.add(\"添加一个奇怪的东西\"); Course cr2 = new Course(2, \"Java基础\"); courses.add(cr2); } public void testForEach() { for (Course cr : courses) { System.out.println(cr.id + \":\" + cr.name); } } public static void main(String[] args) { TestGeneric tg = new TestGeneric(); tg.testAdd(); tg.testForEach(); } } 泛型集合中，不仅可以存放规定的泛型类型，还可以存放 泛型的子类型。 泛型集合中，不支持基本类型，只支持引用类型。可以通过使用包装类限定允许存入的基本数量类型。 public void testBasicType() { // [Syntax error, insert \"Dimensions\" to complete ReferenceType] // List list = new ArrayList(); List list = new ArrayList(); list.add(1000); System.out.println(\"基本类型必须使用包装类作为泛型！\" + list.get(0)); } 例子 Course类 /** * 课程类 * @author capricorncd * */ public class Course { public int id; public String name; public Course (int id, String name) { this.id = id; this.name = name; } // 无参构造器，子类继承时必须调用该无参构造器， // 无，则在子类中编辑器会报错 // [WARNING:Implicit super constructor Course() is undefined for default constructor. Must define an explicit constructor] public Course() { } } ChildCourse类 public class ChildCourse extends Course { } TestGeneric类 public class TestGeneric { // 带有泛型Course的List类型属性 public List courses; // 构造器 public TestGeneric() { this.courses = new ArrayList(); } public void testAdd() { Course cr1 = new Course(1, \"世界地理\"); courses.add(cr1); // 泛型集合中，不能添加泛型规定的类型(及其子类型)以外的对象，否则会报错！ // [WARNING:The method add(Course) in the type List is not applicable for the arguments (Strring)] // courses.add(\"添加一个奇怪的东西\"); Course cr2 = new Course(2, \"Java基础\"); courses.add(cr2); } public void testForEach() { for (Course cr : courses) { System.out.println(cr.id + \":\" + cr.name); } } /** * 泛型集合，可以添加泛型的子类对象实例 */ public void testChild() { ChildCourse ccr = new ChildCourse(); ccr.id = 3; ccr.name = \"我是子类的对象实例\"; courses.add(ccr); } public static void main(String[] args) { TestGeneric tg = new TestGeneric(); tg.testAdd(); tg.testChild(); tg.testForEach(); } } 运行结果： 1:世界地理 2:Java基础 3:我是子类的对象实例 [!WARNING|style:flat|label:注意] 不能使用 基本类型 作为泛型，可以使用对应的包装类。 扩张阅读 https://www.cnblogs.com/coprince/p/8603492.html http://www.runoob.com/java/java-generics.html © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/third-season/set.html":{"url":"pages/third-season/set.html","title":"Set接口，及其实现类HashSet","keywords":"","body":"Set(集)接口，及其实现类 —— HashSet Set是元素无序，并且不可以重复的集合，被称为集。 HashSet：哈希集，是Set的一个重要实现类。 [!NOTE|label:案例功能说明] 提供备选课程 创建学生对象，并给该学生添加三门课程（添加在学生的courses——Set类型的属性中） 显示备选课程 循环三次，每次输入课程ID 往学生的Courses属性中添加与输入的ID匹配的课程 输出学生选课的课程 Student类 import java.util.HashSet; import java.util.Set; /** * 学生类 * @author capricorncd * */ public class Student { public int id; public String name; public Set courses; public Student (int id, String name) { this.id = id; this.name = name; // 初始化 this.courses = new HashSet(); } } TestSet类 import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Scanner; public class TestSet { public List coursesToSelect; // constructor public TestSet() { coursesToSelect = new ArrayList(); } /** * System.out.println * @param str */ public static void print(String str) { System.out.println(str); } /** * 通过for each方法访问集合元素 */ public void testForEach() { print(\"-------------- testForEach ---------------\"); print(\"有以下课程待选(通过forEach访问)：\"); for (Object obj : coursesToSelect) { Course cr = (Course) obj; print(\"Course: \" + cr.id + \" \" + cr.name); } print(\"-------------- 华丽的分割线 ---------------\"); } /** * 添加备课程 */ public void testAdd() { coursesToSelect.add(new Course(1, \"数据结构\")); coursesToSelect.add(new Course(2, \"C语言\")); // 批量添加课程 Course[] courses = { new Course(3, \"离散数学\"), new Course(4, \"汇编语言\"), new Course(5, \"高等数学\"), new Course(6, \"GoLang\") }; coursesToSelect.addAll(Arrays.asList(courses)); } /** * 遍历输出学生的课程 * @param student */ public void forEachForSet(Student student) { print(student.name + \"成功选择了\" + student.courses.size() + \"门课程！\"); for (Course cr : student.courses) { print(cr.id + \":\" + cr.name); } } public static void main(String[] args) { TestSet ts = new TestSet(); ts.testAdd(); ts.testForEach(); // 创建一个学生对象 Student student = new Student(1, \"John\"); print(\"欢迎学生：\" + student.name + \"选课！\"); // 创建一个Scanner对象，用来接收从键盘输入的课程ID Scanner input = new Scanner(System.in); // 循环三次，每次输入课程ID for (int i = 0; i [!WARNING|style:flat|label:注意] Set 只能使用 foreach或iterator遍历，不能像List那样使用get()方法。 因为Set是无序的，不能通过索引去查找元素，只能通过foreach或iterator一个个循环迭代出来。而且每次迭代出来的结果顺序都可能不同。 Set中可以添加 null 空对象，不过在实际应用中不常见。 代码 https://github.com/capricorncd/Java-Notes/tree/master/codes/collection-and-map/src/com/test/collection © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/third-season/map.html":{"url":"pages/third-season/map.html","title":"Map & HashMap","keywords":"","body":"Map & HashMap Map接口 Map提供了一种 映射关系，其中的元素以键值对（key-value）的形式存储，能够实现根据key快速查找value。 key/value可以是任意类型的对象。并且可以根据key值，快速找查找到对应的value值。 Map中的键值对以Entry类型的对象实例形式存在。 键（key值）不可重复，value值可以。每个键最多只能映射到一个值。 Map支持泛型，形式如：Map HashMap类 HashMap是Map的一个重要实现类，也是最常用的，基于哈希表实现。 HashMap中的Entry对象是无序排列的。 Key值和Value值都可以为null，但是一个HashMap只能有一个key值的null的映射（key值不可重复）。 [!NOTE|label:案例功能说明] 通过Map进行学生信息管理，其中key为学生ID，value为学生对象。 通过键盘输入学生信息。 对集合中的学生信息进行增/删/改/查操作。 Student2类 import java.util.HashSet; import java.util.Set; public class Student2 { public String id; public String name; public Set courses; public Student2(String id, String name) { this.id = id; this.name = name; this.courses = new HashSet(); } } TestMap类 import java.util.HashMap; import java.util.Map; import java.util.Map.Entry; import java.util.Scanner; import java.util.Set; public class TestMap { // 承装学生类型对象 public Map students; /** * 创建构造函数，并初始化students属性 */ public TestMap() { this.students = new HashMap(); } /** * 添加学生数据：输入学生ID，判断是否被占用 * 若未被占用，则输入姓名，创建新学生对象， * 并且添加到students中 */ public void testPut() { // 创建一个Scanner对象，用于获取输入的学生ID和姓名 Scanner console = new Scanner(System.in); int i = 0; while (i studentKeys = students.keySet(); // 遍历keySet，取得每一个键，再调用get方法，获取对应value值 for (String studentID : studentKeys) { Student2 st = students.get(studentID); if (st != null) { System.out.println(\"学生：\" + st.id + \":\" + st.name); } } System.out.println(\"------ 共有\" + students.size() + \"位学生。\"); } /** * 测试Map的remove方法 */ public void testRemove() { Scanner console = new Scanner(System.in); while(true) { System.out.println(\"请输入需要删除的学生ID：\"); String ID = console.next(); Student2 st = students.get(ID); if (st != null) { students.remove(ID); System.out.println(\"成功删除学生：\" + st.name); break; } else { System.out.println(\"ID对应的学生不存在！\"); continue; } } } /** * 测试Map的entrySet方法 */ public void testEntrySet() { System.out.println(\"---------- testEntrySet ----------\"); // 通过entrySet方法，返回Map中的所有键值对 Set> entrySet = students.entrySet(); for (Entry entry : entrySet) { System.out.println(\"取得键值对：\" + entry.getKey() + \"=>\" + entry.getValue().name); } } /** * 测试put修改内容 */ public void testModify() { System.out.println(\"请输入需要修改的学生ID：\"); Scanner console = new Scanner(System.in); while (true) { String studentID = console.next(); Student2 st = students.get(studentID); if (st == null) { System.out.println(\"输入的学生ID不存在，请重新输入：\"); continue; } System.out.println(\"当前学生ID，对应的学生为：\" + st.name); System.out.println(\"请输入新的学生姓名：\"); String name = console.next(); Student2 newStudent = new Student2(studentID, name); students.put(studentID, newStudent); System.out.println(\"修改成功！\"); break; } } public static void main(String[] args) { TestMap tm = new TestMap(); tm.testPut(); tm.testKeySet(); tm.testRemove(); tm.testEntrySet(); tm.testModify(); tm.testEntrySet(); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/third-season/questions.html":{"url":"pages/third-season/questions.html","title":"- 问题思考","keywords":"","body":"问题思考 [!NOTE|label:问题思考] 在课程序列中，如何判断是否包含某门或者某几门课程？ 如果课程序列包含某门课程，如果判断该课程的索引位置？ 在学生映射表中，如何判断是否包含某个学ID？ 又该如何判断是否包含某个学生对象？ 如何按照课程名称或者学生姓名排序？或是按ID排序？ TestSet.java public void testLsitContains() { // 获取备选课程的第0个元素 Course course = coursesToSelect.get(0); // 打印输出coursesToSelect是否包含course对象 System.out.println(\"取得课程：\" + course.name); System.out.println(\"备选课程中是否包含课程：\" + course.name + \", \" + coursesToSelect.contains(course)); // 创建一个新的课程对象，ID和名称，与course对象完全一样 Course courseB = new Course(course.id, course.name); System.out.println(\"取得课程：\" + courseB.name); System.out.println(\"备选课程中是否包含课程B：\" + courseB.name + \", \" + coursesToSelect.contains(courseB)); } [!NOTE|style:flat|label:List contains()] 在课程序列中，如何判断是否包含某门或者某几门课程？ 运行结果： 取得课程：数据结构 备选课程中是否包含课程：数据结构, true 取得课程：数据结构 备选课程中是否包含课程B：数据结构, false 重写Course类的equals方法 @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (!(obj instanceof Course)) return false; Course course = (Course) obj; if (this.name == null) { return course.name == null; } else { return this.name.equals(course.name); } } 再次运行TestSet类，输出结果： 取得课程：数据结构 备选课程中是否包含课程：数据结构, true 取得课程：数据结构 备选课程中是否包含课程B：数据结构, true [!NOTE|style:flat|label:List indexOf()] 如果课程序列包含某门课程，如果判断该课程的索引位置？ indexOf: 列表头开始遍历，获取元素第一次出现位置的索引。 lastIndexOf：从列表尾部（队尾）开始遍历，获取元素最后一次出现的位置索引。 [!NOTE|style:flat|label:Map containsKey(), containseValue()] 在Map中，用containsKey()方法，判断是否包含某个key值 使用containsValue()方法，判断是否包含某个Value值 /** * 测试containsKey and containsValue方法 */ public void testContainsKeyOrValue() { // 提示输入学生ID System.out.println(\"请输入要查询的学生ID：\"); Scanner console = new Scanner(System.in); String id = console.next(); // 在Map中，用containsKey()方法，判断是否包含某个key值 System.out.println(\"您输入的学生ID为：\" + id + \", 在学生映射表中是否存在：\" + students.containsKey(id)); if (students.containsKey(id)) { System.out.println(\"对应的学生是：\" + students.get(id).name); } // 提示用户按姓名查询 System.out.println(\"请输入要查询的学生姓名：\"); String name = console.next(); // 使用containsValue()方法，判断是否包含某个Value值 if (students.containsValue(new Student(0, name))) { System.out.println(\"学生映射表中包含学生：\" + name); } else { System.out.println(\"学生\" + name + \"不存在!\"); } } 重写学生类的equals，hash方法。IDE自动生成： 鼠标右键代码区（或IDE菜单栏）Source -> Generate hashCode() and equals()... 勾选Use 'instanceof' to compare types项 @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (!(obj instanceof Student)) return false; Student other = (Student) obj; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } 代码 https://github.com/capricorncd/Java-Notes/tree/master/codes/collection-and-map/src/com/test/collection © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/third-season/collections.html":{"url":"pages/third-season/collections.html","title":"Collections工具类","keywords":"","body":"Collections工具类 java.util.Collections 是Java集合框架中，用来操作集合对象的工具类；也是Java集合框架的成员。 Comparable和Comparator Comparable: 默认比较规则； Comparator: 临时比较规则； Comparable和Comparator都是Java集合框架的成员。 Comparable接口 —— 可比较的 实现该接口表示：这个类的实例可以比较大小，可以进行自然排序 定义了默认的比较规则 其实现类需要实现compareTo()方法 compareTo()方法返回正数表示大，负数表示小，0则表示相等。 import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Random; /** * 需求： * 1、通过Collections.sort()方法，对Integer泛型的List进行排序； * 2、对String泛型的List进行排序； * 3、对其他类型泛型的List进行排序，以Student2为列 */ public class TestCollection { /** * 1、通过Collections.sort()方法，对Integer泛型的List进行排序； * 创建Integer泛型的List，插入10个100以内的不重复随机整数 * 调用Collections.sort()方法对其进行排序 */ public void testSort1() { List integerList = new ArrayList(); // 插入十个100以内的不重复随机整数 Random random = new Random(); Integer k; for (int i = 0; i stringList = new ArrayList(); stringList.add(\"huawei\"); stringList.add(\"alibaba\"); stringList.add(\"jingdong\"); System.out.println(\"------- before sort -------\"); StringBuilder str1 = new StringBuilder(); for (String str : stringList) { str1.append(str + \" \"); } System.out.println(str1); // 排序 System.out.println(\"------- after sort -------\"); // string排序规则 // 0-9，A-Z，a-z Collections.sort(stringList); StringBuilder str2 = new StringBuilder(); for (String str : stringList) { str2.append(str + \" \"); } System.out.println(str2); } /** * 3、对其他类型泛型的List进行排序，以Student2为列 * Comparable和Comparator */ public void testSort3() { List studentList = new ArrayList(); Random random = new Random(); studentList.add(new Student(random.nextInt(1000), \"Jack\")); studentList.add(new Student(random.nextInt(1000), \"Maria\")); studentList.add(new Student(random.nextInt(1000), \"Tomson\")); System.out.println(\"------- before sort -------\"); StringBuilder str1 = new StringBuilder(); for (Student st : studentList) { str1.append(st.id + \":\" + st.name + \" \"); } System.out.println(str1); System.out.println(\"------- after sort -------\"); // 未实现Comparable接口前，会报以下错误： // [WARNING:The method sort(List) in the type Collections is not applicable for the arguments (List)] Collections.sort(studentList); StringBuilder str2 = new StringBuilder(); for (Student st : studentList) { str2.append(st.id + \":\" + st.name + \" \"); } System.out.println(str2); } public static void main(String[] args) { TestCollection tc = new TestCollection(); tc.testSort1(); tc.testSort2(); tc.testSort3(); } } Student类 import java.util.HashSet; import java.util.Set; /** * 学生类 * @author capricorncd * */ public class Student implements Comparable { public int id; public String name; public Set courses; @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (!(obj instanceof Student)) return false; Student other = (Student) obj; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } public Student (int id, String name) { this.id = id; this.name = name; // 初始化 this.courses = new HashSet(); } @Override public int compareTo(Student o) { // String // return this.name.compareTo(o.name); return this.id - o.id; } } 注意：当id为String类型时，其结果： [!NOTE|style:flat|label:扩展练习] 利用Collections.sort()方法，对泛型为String的List进行排序 创建完List后，往其中添加10条随机字符串 每条字符串长度为10以内的随机整数 每条字符串的每个字符都为随机生成的字符，字符可以重复 每条随机字符串不可重复 Comparator接口 —— 比较工具接口 用户定义临时比较规则，而不是默认比较规则。 其实现类需要实现compare()方法。 可以将Comparator传递给sort方法（如Collections.sort或Arrays.sort） package com.test.collection; import java.util.Comparator; public class StudentComparator implements Comparator { @Override public int compare(Student o1, Student o2) { // 按学生姓名排序 return o1.name.compareTo(o2.name); } } 改造TestCollection类testSrot3方法 /** * 3、对其他类型泛型的List进行排序，以Student2为列 * Comparable和Comparator */ public void testSort3() { List studentList = new ArrayList(); Random random = new Random(); studentList.add(new Student(random.nextInt(1000), \"Jack\")); studentList.add(new Student(random.nextInt(1000), \"Maria\")); studentList.add(new Student(random.nextInt(1000), \"Tomson\")); System.out.println(\"------- before sort -------\"); StringBuilder str1 = new StringBuilder(); for (Student st : studentList) { str1.append(st.id + \":\" + st.name + \" \"); } System.out.println(str1); // id排序 System.out.println(\"------- after sort -------\"); // 未实现Comparable接口前，会报以下错误： // [WARNING:The method sort(List) in the type Collections is not applicable for the arguments (List)] Collections.sort(studentList); StringBuilder str2 = new StringBuilder(); for (Student st : studentList) { str2.append(st.id + \":\" + st.name + \" \"); } System.out.println(str2); // 姓名排序 System.out.println(\"------- sort by name -------\"); Collections.sort(studentList, new StudentComparator()); StringBuilder str3 = new StringBuilder(); for (Student st : studentList) { str3.append(st.id + \":\" + st.name + \" \"); } System.out.println(str3); } 运行结果： ------- before sort ------- 894:Jack 210:Maria 968:Tomson ------- after sort ------- 210:Maria 894:Jack 968:Tomson ------- sort by name ------- 894:Jack 210:Maria 968:Tomson © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/third-season/game-test.html":{"url":"pages/third-season/game-test.html","title":"综合练习——洗牌发牌Easy版","keywords":"","body":"综合练习——洗牌发牌Easy版 功能需求 1、创建一副扑克牌 包括4种花色：黑红英方 13种点数：2-10，J，Q，K，A，不考虑大小王 2、创建2名玩家 玩家至少有ID/姓名/手牌等属性，手牌为扑克牌的集合 3、洗牌 将之前创建的\"一副扑克牌\"打乱 顺序。 4、发牌 将洗牌之后的扑克牌集合，从第一张开始，发给2名玩家，按照一人一张的方式，每人发2张。 5、游戏 比较2名玩家手中的扑克牌，规则为：取两人各种手中点数最大的牌进行比较，点数大的赢；若两人各自点数最大牌相等，则再按花色比较。 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/third-season/reflect.html":{"url":"pages/third-season/reflect.html","title":"Java反射机制","keywords":"","body":"Java反射机制 往往当我们面对一项新的知识时，我们往往需要知道三个方面，它是什么，它能做什么，它比原有知识强在哪里，我们该怎么使用它。当你能够解决这些问题时，便意味着你已经对这项知识入门了。 是什么 Java Reflaction in Action有这么一句话，可以解释。反射是运行中的程序检查自己和软件运行环境的能力，它可以根据它发现的进行改变。通俗的讲就是反射可以在运行时根据指定的类名获得类的信息。 为什么 我们为什么要使用反射，它的作用是什么，它在实际的编程中有什么应用。 首先我们先明确两个概念，静态编译和动态编译。 静态编译：在编译时确定类型，绑定对象,即通过。 动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性。 我们可以明确的看出动态编译的好处，而反射就是运用了动态编译创建对象。 那么我们再来看看实际中反射又有什么好处那？ 往往对比能更加直观的向我们展示两者的不同。 先从某个代码案例上来解释（套用一篇博文的一个例子：http://blog.csdn.net/justdoit_potato/article/details/51011843） 若是不用反射，它是这样的 interface Fruit { public abstract void eat(); } class Apple implements Fruit { public void eat() { System.out.println(\"Apple\"); } } class Orange implements Fruit { public void eat() { System.out.println(\"Orange\"); } } // 构造工厂类 // 也就是说以后如果我们在添加其他的实例的时候只需要修改工厂类就行了 class Factory { public static Fruit getInstance(String fruitName) { Fruit f = null; if(\"Apple\".equals(fruitName)){ f = new Apple(); } if(\"Orange\".equals(fruitName)){ f = new Orange(); } return f; } } class Hello { public static void main(String[] a){ Fruit f = Factory.getInstance(\"Orange\"); f.eat(); } } 可以发现，每当我们要添加一种新的水果的时候，我们将不得不改变Factory中的源码，而往往改变原有正确代码是一种十分危险的行为。而且随着水果种类的增加，你会发现你的factory类会越来越臃肿。 反射机制实现 // Fruit.java package com.reflaction.demo; public interface Fruit { public abstract void eat(); } // Apple.java public class Apple implements Fruit { @Override public void eat() { // TODO Auto-generated method stub System.out.println(\"Eat Apple\"); } } // Orange.java public class Orange implements Fruit { @Override public void eat() { // TODO Auto-generated method stub System.out.println(\"Eat orange\"); } } // Fruit.java public class Factory { public static Fruit getInstance(String className) { Fruit fruit = null; try { fruit = (Fruit)Class.forName(className).newInstance(); } catch (Exception e) { e.printStackTrace(); } return fruit; } } // Main.java public class Main { public static void main(String[] args) { // TODO Auto-generated method stub Fruit fruit = Factory.getInstance(\"com.reflaction.demo.Apple\"); if (fruit != null) fruit.eat(); } } 在出现新品种水果的时候，你完全不用去修改原有代码。 从上面的案例中，我们可以清楚的体会到反射的优越性。 那么有的人又会问，这个例子能完全明白，但是如果放到实际的编程，应用中，我们又会在什么情况下用到反射那？ 举一个看到过的例子，在实际开发中，我们需要把一个包中的class new出来，但是这个包中的类总是需要变动，那么怎么办，难道总是修改main方法中xxx=new xxx()吗。这样无疑是麻烦的。而运用反射。我们可以相应的增加一个配置文件，在里面记录包中所有的类名，包中类增加时就加一个类名，删除时就删除一个类名。让main方法去读取这个配置文件中的类名，通过反射获得实例，完全不用我们去修改main方法中的代码。 反射还有什么用那？他甚至可以修改其他类中的私有属性。android开发中，我们需要改变一个私有标志位的时候，android源码并没有提供set方法，我们又不能改变源码，怎么办，反射可以完美解决这个问题。 说了这么多，那么我们的开发中，为什么不全部都用反射那？一个原因，开销，它的开销是什么昂贵的，随意尽量在最需要的地方使用反射。 怎么用 说完是什么，为什么，我们必然需要掌握如何使用反射，先看反射中涉及了那些方法。 Class c = Class.forName(\"className\"); 注明：className必须为全名，也就是得包含包名，比如cn.netjava.pojo.UserInfo; Object obj = c.newInstance(); //创建对象的实例 OK，有了对象就什么都好办了，想要什么信息就有什么信息了。 获得构造函数的方法 // 根据指定参数获得public构造器 Constructor getConstructor(Class[] params) // 获得public的所有构造器 Constructor[] getConstructors() // 根据指定参数获得public和非public的构造器 Constructor getDeclaredConstructor(Class[] params) //获得public的所有构造器 Constructor[] getDeclaredConstructors() 获得类方法的方法 // 根据方法名，参数类型获得方法 Method getMethod(String name, Class[] params) // 获得所有的public方法 Method[] getMethods() // 根据方法名和参数类型，获得public和非public的方法 Method getDeclaredMethod(String name, Class[] params) // 获得所以的public和非public方法 Method[] getDeclaredMethods() 获得类中属性的方法 // 根据变量名得到相应的public变量 Field getField(String name) // 获得类中所以public的方法 Field[] getFields() // 根据方法名获得public和非public变量 Field getDeclaredField(String name) // 获得类中所有的public和非public方法 Field[] getDeclaredFields() 看到这些方法，你就可以明白，反射是多么的强大了，当你正确使用这些方法的时候，基本上是掌握了反射的技巧。 原文出处 https://www.cnblogs.com/yrstudy/p/6500982.html © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/spring/":{"url":"pages/spring/","title":"Spring框架简介","keywords":"","body":"Spring 框架简介 Spring 是一个开源框架，是为了解决企业应用程序开发复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许您选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。 下载地址： https://repo.spring.io/release/org/springframework/spring/ https://repo.spring.io/libs-release-local/org/springframework/spring/ 这里主要学习： 其轻量级的控制反转(IoC)和面向切面(AOP)的容器框架 大小与开销两方面而言Spring都是轻量级的。 通过控制反转(IoC)的技术达到松耦合的目的。 提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统服务进行内聚性的开发。(比如商品管理：商品的出库入库就是业务逻辑；如入库和出库都要统一的日志记录和数额管理，与具体的业务无关，无论什么样的业务都要使用到服务，就把它称为系统服务) 包含并管理应用对象的配置和生命周期，这个意义上是一种容器，即对象的创建和销毁都是由Spring自己完成 将简单的组件配置、组合成为复杂的应用，这个意义上讲Spring就是一个框架 为什么是Spring 在Spring上开发应用简单、方便、快捷 Spring带来了复杂JavaEE开发的春天 核心容器 核心容器由spring-core，spring-beans，spring-context，spring-context-support和spring-expression（SpEL，Spring表达式语言，Spring Expression Language）等模块组成，它们的细节如下： spring-core模块提供了框架的基本组成部分，包括 IoC 和依赖注入功能。 spring-beans 模块提供 BeanFactory，工厂模式的微妙实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。 context模块建立在由core和 beans 模块的基础上建立起来的，它以一种类似于JNDI注册的方式访问对象。Context模块继承自Bean模块，并且添加了国际化（比如，使用资源束）、事件传播、资源加载和透明地创建上下文（比如，通过Servelet容器）等功能。Context模块也支持Java EE的功能，比如EJB、JMX和远程调用等。ApplicationContext接口是Context模块的焦点。spring-context-support提供了对第三方库集成到Spring上下文的支持，比如缓存（EhCache, Guava, JCache）、邮件（JavaMail）、调度（CommonJ, Quartz）、模板引擎（FreeMarker, JasperReports, Velocity）等。 spring-expression模块提供了强大的表达式语言，用于在运行时查询和操作对象图。它是JSP2.1规范中定义的统一表达式语言的扩展，支持set和get属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从Spring IoC容器检索对象，还支持列表的投影、选择以及聚合等。 它们的完整依赖关系如下图所示： 数据访问/集成 数据访问/集成层包括 JDBC，ORM，OXM，JMS 和事务处理模块，它们的细节如下： （注：JDBC=Java Data Base Connectivity，ORM=Object Relational Mapping，OXM=Object XML Mapping，JMS=Java Message Service） JDBC 模块提供了JDBC抽象层，它消除了冗长的JDBC编码和对数据库供应商特定错误代码的解析。 ORM 模块提供了对流行的对象关系映射API的集成，包括JPA、JDO和Hibernate等。通过此模块可以让这些ORM框架和spring的其它功能整合，比如前面提及的事务管理。 OXM 模块提供了对OXM实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等。 JMS 模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了spring-messaging模块。。 事务模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。（注：编程式事务需要自己写beginTransaction()、commit()、rollback()等事务管理方法，声明式事务是通过注解或配置由spring自动处理，编程式事务粒度更细） Web Web 层由 Web，Web-MVC，Web-Socket 和 Web-Portlet 组成，它们的细节如下： Web 模块提供面向web的基本功能和面向web的应用上下文，比如多部分（multipart）文件上传功能、使用Servlet监听器初始化IoC容器等。它还包括HTTP客户端以及Spring远程调用中与web相关的部分。。 Web-MVC 模块为web应用提供了模型视图控制（MVC）和REST Web服务的实现。Spring的MVC框架可以使领域模型代码和web表单完全地分离，且可以与Spring框架的其它所有功能进行集成。 Web-Socket 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。 Web-Portlet 模块提供了用于Portlet环境的MVC实现，并反映了spring-webmvc模块的功能。 其他 还有其他一些重要的模块，像 AOP，Aspects，Instrumentation，Web 和测试模块，它们的细节如下： AOP 模块提供了面向方面的编程实现，允许你定义方法拦截器和切入点对代码进行干净地解耦，从而使实现功能的代码彻底的解耦出来。使用源码级的元数据，可以用类似于.Net属性的方式合并行为信息到代码中。 Aspects 模块提供了与 AspectJ 的集成，这是一个功能强大且成熟的面向切面编程（AOP）框架。 Instrumentation 模块在一定的应用服务器中提供了类 instrumentation 的支持和类加载器的实现。 Messaging 模块为 STOMP 提供了支持作为在应用程序中 WebSocket 子协议的使用。它也支持一个注解编程模型，它是为了选路和处理来自 WebSocket 客户端的 STOMP 信息。 测试模块支持对具有 JUnit 或 TestNG 框架的 Spring 组件的测试。 Spring作用 容器 通过了对多种技术的支持：JMS、MQ支持、UnitTest、... AOP(事务管理、日志等) 提供了众多方便应用的辅助类(JDBC Template等) 对主流应用框架(Hibernate等）提供了良好的支持 适用范围 构建企业应用(SpringMVC+Spring+Hibernate/iBATIS) 单独使用Bean容器(Bean管理) 单独使用AOP进行切面处理 其他的Spring功能，如：对消息的支持等 在互联网中的应用... 软件框架 维基百科：软件框架，通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组织规范时，提供规范所要求的基础功能的软件产品。 [!TIP|style:flat|label:框架] 是制定一套规范或规则（思想），大家（程序员）在该规范或者规则（思想）下工作。或者说就是使用别人搭好的舞台，你来做表演。 特点： 半成品 封装了特定的处理流程和控制逻辑。（处理流程是为了完成自身的处理流程） 成熟的、不断升级改进的软件 框架与类库的区别 框架一般是封装了逻辑、高内聚的，类库则是松散的工具组合 框架专注于某一领域，类库则是更通用的 类库通过不同的组合，可以组合出不同的框架 为什么使用框架 软件系统日趋复杂 重用度高，开发效率和质量提高 软件设计人员要专注于对领域的了解，使需求分析充分 框架有完整的文档，易于学习、上手、快速解决问题 参考资料&&扩展阅读 https://www.imooc.com/learn/196 https://www.ibm.com/developerworks/cn/java/wa-spring1/ https://www.w3cschool.cn/wkspring/ © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/spring/j-unit.html":{"url":"pages/spring/j-unit.html","title":"JUnit4","keywords":"","body":"JUnit4 https://github.com/junit-team/junit4 Eclipse Jee 2018-12中自动继承了JUnit4、5等 [!WARNING|style:flat|label:注意] 测试用例不是用来证明程序是对的，而是用来证明程序没有错。 测试用例用来达到想要的预期结果，但对于逻辑错误无能为力。 src/ package com.test.util; public class Calculate { public int add(int a, int b) { return a + b; } public int subtract(int a, int b) { return a - b; } public int multiply(int a, int b) { return a * b; } public int divide(int a, int b) { return a / b; } } test/ package com.test.util; import static org.junit.Assert.*; import org.junit.Test; public class CalculateTest { @Test public void testAdd() { assertEquals(6, new Calculate().add(3, 3)); } @Test public void testSubtract() { assertEquals(3, new Calculate().subtract(10, 7)); } @Test public void testMultiply() { assertEquals(10, new Calculate().multiply(2, 5)); } @Test public void testDivide() { assertEquals(10, new Calculate().divide(80, 8)); } } [!TIP|style:flat|label:总结] 测试方法上必须使用@Test进行修饰 测试方法必须使用public void进行修饰，不能带任何的参数 新建一个源代码目录来存放我们的测试代码 测试类的包，应和被测试类保持一致 测试单元中的每个方法必须可以独立测试，测试方法间不能有任何的依赖 测试类使用Test作为类名的后缀（非必须） 测试方法使用test作为方法前缀（非必须） 测试失败的两种情况 package com.test.util; import static org.junit.Assert.*; import org.junit.Test; public class ErrorAndFailureTest { @Test public void testAdd() { assertEquals(5, new Calculate().add(3, 3)); } @Test public void testDivide() { assertEquals(10, new Calculate().divide(80, 0)); } } [!TIP|style:flat|label:总结] Failure一般由单元测试的断言方法判断失败所引起的，这经表示测试点发现了问题，即程序输出的结果和我们预期的不一样。 Error是由代码异常引起，可能是测试代码本身有错误，或是被测代码中有隐藏bug 测试用例不是用来证明程序是对的，而是用来证明程序没有错误。 JUnit运行流程 package com.test.util; import static org.junit.Assert.*; import org.junit.After; import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Test; public class JUnitFlowTest { @BeforeClass public static void setUpBeforeClass() throws Exception { System.out.println(\"setUpBeforeClass\"); } @AfterClass public static void tearDownAfterClass() throws Exception { System.out.println(\"tearDownAfterClass\"); } @Before public void setUp() throws Exception { System.out.println(\"setUp\"); } @After public void tearDown() throws Exception { System.out.println(\"tearDown\"); } @Test public void test1() { System.out.println(\"test1\"); } @Test public void test2() { System.out.println(\"test2\"); } } 结果： setUpBeforeClass setUp test1 tearDown setUp test2 tearDown tearDownAfterClass [!TIP|style:flat|label:总结] @BeforeClass修饰的方法会在所有方法被调用前被执行，而且该方法时静态的，所以当测试类被加载后接着就会运行它。而且在内存中它只会存在一个实例，它比较适合加载配置文件。 @AfterClass所修饰的方法通常用来对资源的清理，如关闭数据库的连接。 @Before和@After会在每个测试方法的前后各执行一次。 JUnit4常用注解 a notation 英 [ə nəʊˈteɪʃn] 美 [ə noʊˈteɪʃn] 记号 package com.test.util; import static org.junit.Assert.*; import org.junit.Ignore; import org.junit.Test; public class AnotationTest { @Test(expected=ArithmeticException.class) public void testDivide() { assertEquals(10, new Calculate().divide(10, 0)); } @Ignore @Test(timeout=1000) public void testWhile() { int i = 1; while(true) { System.out.println(\"run forevet \" + i); } } /** * 我们预期的是3秒，程序读取时间是2秒，达到了预期 */ @Test(timeout=3000) public void testReadFile() { try { Thread.sleep(2000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 注释 说明 @Test 将一个普通方法修饰成为一个测试方法 @Test(expected=XX.class)异常捕获 @Test(timeout=毫秒)超时处理，如处理死循环，或性能测试等 @BeforeClass 它会在所有方法运行前被执行，static修饰 @AfterClass 它会在所有方法运行结束后被执行，static修饰 @Before 会在每一个测试方法运行前被执行一次 @After 会在每一个测试方法运行后被执行一次 @Ignore 所修饰的测试方法会被测试运行器忽略 @Ignore(message) @RunWith 可以更改测试运行器org.junit.runner.Runner JUnit4测试套件 package com.test.util; import org.junit.runner.RunWith; import org.junit.runners.Suite; @RunWith(Suite.class) @Suite.SuiteClasses({TaskTest1.class, TaskTest2.class, TaskTest3.class}) public class SuiteTest { } TaskTest1, TaskTest2, TaskTest3 package com.test.util; import org.junit.Test; public class TaskTest3 { @Test public void test() { System.out.println(\"This is TaskTest3\"); } } 结果： This is TaskTest1 This is TaskTest2 This is TaskTest3 [!TIP|style:flat|label:总结] 测试套件就是组织测试类一起运行的 写一个作为测试套件的入口类，这个类里不包含其他的方法 更改测试运行器Suite.class 将要测试的类作为数组传入到Suite.SuiteClasses({}) JUnit4参数化设置 目的：解决以上大同小异的测试代码问题 package com.test.util; import static org.junit.Assert.*; import java.util.Arrays; import java.util.Collection; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters; @RunWith(Parameterized.class) public class ParameterTest { int expected = 0; int input1 = 0; int input2 = 0; @Parameters public static Collection t() { return Arrays.asList(new Object[][] { {3, 1, 2}, {4, 2, 2} }); } public ParameterTest(int expected, int input1, int input2) { this.expected = expected; this.input1 = input1; this.input2 = input2; } @Test public void testAdd() { assertEquals(expected, new Calculate().add(input1, input2)); } } [!TIP|style:flat|label:总结] 更改默认的测试运行器为@RunWith(Parameterized.class) 声明变量来存放预期值和结果值 声明一个返回值为Collection的公共静态方法，并使用@Parameters进行修饰 为测试类声明一个带有参数的公共构造函数，并在其中为之声明变量赋值 spring与hibernate的整合测试 注意：需要导入commons.logging的包，否则单元测试会失败。 spring测试 src/application-context.xml test/ package com.test.conform; import static org.junit.Assert.*; import java.util.Date; import org.junit.BeforeClass; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.*; public class SpringTest { private static ApplicationContext context = null; @BeforeClass public static void setUpBeforeClass() throws Exception { context = new ClassPathXmlApplicationContext(\"application-context.xml\"); } @Test public void test() { Date date = (Date)context.getBean(\"date\"); System.out.println(date); } } 结果： log4j:WARN No appenders could be found for logger (org.springframework.core.env.StandardEnvironment). log4j:WARN Please initialize the log4j system properly. Sun Jul 14 22:06:27 JST 2019 spring与hibernate的整合测试 未实现！ © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/spring/ioc.html":{"url":"pages/spring/ioc.html","title":"IoC及bean容器","keywords":"","body":"IoC及bean容器 接口 用于沟通的中介物的抽象化 实体把自己提供给外界的一种抽象化说明，用以由内部操作分离出外部沟通方法，使其能被修改内部而不影响外界其他实体与其交换的方式 对应Java接口即声明，声明了哪些方法时对外公开提供的 在Java8中，接口可以拥有方法体 面向接口编程 结构设计中，分清层次及调用关系，每层只向外（上层）提供一组功能接口，各层间仅依赖接口而非实现类 接口实现的变动不影响各层间的调用，这一点在公共服务中尤为重要 \"面向接口编程\"中的\"接口\"是用于隐藏具体实现和实现多态性的组件 OneInterface.java package com.test; public interface OneInterface { String hello(String str); } OneInterfaceImpl.java package com.test; public class OneInterfaceImpl implements OneInterface { @Override public String hello(String str) { return \"Word from interface \\\"OneInterface\\\": \" + str; } } Main.java package com.test; public class Main { public static void main(String[] args) { OneInterfaceImpl oif = new OneInterfaceImpl(); System.out.println(oif.hello(\"World\")); } } Spring的Bean配置 上面的接口在Spring中的配置方式 IOC 控制反转 控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护。 DI(依赖注入Dependency Injection)是其一种实现方式 目的创建对象并且组装对象之间的关系 比如我们住的房子，不会自己画图纸修建，而是之间找开发商或中介购买使用。 扩展阅读 百度百科 https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/1158025 浅谈IOC--说清楚IOC是什么 https://blog.csdn.net/ivan820819/article/details/79744797 什么是IOC(控制反转)、DI(依赖注入) https://blog.csdn.net/qq_42709262/article/details/81951402 扩展理解 2004年，Martin Fowler探讨了同一个问题，既然IOC是控制反转，那么到底是“哪些方便的控制被反转了？”。经过详细地分析和论证后，他得出答案：获得依赖对象的过程被反转了。控制被反转之后，获得依赖对象的过程由自身管理变为由IOC容器主动注入。 于是他给控制反转取了一个更合适的名字依赖注入Dependency Injection。他的这个答案实际上给出了实现IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。 房屋中介 IOC 找中介 => 找IOC容器 中介介绍房子 => 容器返回对象 租房、入住 => 使用对象 自从有了IOC之后 不必自己创建对象了 IOC机制就提供了 面向接口编程了 IOC藏实现了 不管对象了（不要自己去new 类） IOC管了 变好了 IOC ... 单元测试 下载junit-*.jar并引入工程 创建UnitTestBase类，完成对Spring配置文件的加载、销毁 所有的单元测试类都继承自UnitTestBase，通过它的getBean方法获取想要得到的对象 子类（具体执行单元测试的类）加注解：@RunWith(BlockJUnit4ClassRunner.class) 单元测试方法加注解：@Test 右键选择要执行的单元测试方法执行或者执行一个类的全部单元测试方法 Bean容器初始化 基础：两个包 org.springframework.beans org.springframework.context BeanFactory提供配置结构和基本功能，加载并初始化Bean ApplicationContext保存了Bean对象并在Spring中被广泛使用 初始化方式，ApplicationContext 加载本地文件，即指定磁盘上的指定文件 FileSystemXmlApplicationContext context = new FileSystemXmlApplicationContext(\"C:/workspace/app-context.xml\"); Classpath，相对路径，相对工程的一个路径 // Classpath ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:spring-context.xml\"); Web应用中依赖Servlet或Listener org.springframework.web.context.ContextLoaderListener context org.springframework.web.context.ContextLoaderServlet 1 Spring注入 Spring注入是指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为 常用的两种注入方式： 设值注入 构造注入 实例代码 src/spring-injection.xml --> test/ package com.test.injection.service; public interface InjectionService { public void save(String arg); } package com.test.injection.service; import com.test.injection.dao.InjectionDAO; /** * XxServiceImpl * 主要用于处理业务逻辑部分 * @author capricorncd * */ public class InjectionServiceImpl implements InjectionService { private InjectionDAO injectionDAO; // 构造器注入 // 对应xml文件： public InjectionServiceImpl(InjectionDAO injectionDAO) { this.injectionDAO = injectionDAO; } // 设值注入 // 对应xml文件： public void setInjectionDAO(InjectionDAO injectionDAO) { this.injectionDAO = injectionDAO; } public void save(String arg) { // 模拟业务操作 System.out.println(\"Service接收参数：\" + arg); arg = arg + \":\" + this.hashCode(); injectionDAO.insert(arg); } } package com.test.injection.dao; public interface InjectionDAO { public void insert(String arg); } package com.test.injection.dao; /** * XxDAOImpl * 主要用于操作数据库部分 * @author capricorncd * */ public class InjectionDAOImpl implements InjectionDAO { // 模拟数据库保存操作 public void insert(String arg) { System.out.println(\"保存数据：\" + arg); } } Test package com.test.ioc.interfaces; import static org.junit.Assert.*; import org.junit.BeforeClass; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.BlockJUnit4ClassRunner; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import com.test.injection.service.InjectionService; @RunWith(BlockJUnit4ClassRunner.class) public class InjectionTest { private static ApplicationContext context; @BeforeClass public static void setUpBeforeClass() throws Exception { context = new ClassPathXmlApplicationContext(\"spring-injection.xml\"); } @Test public void test() { InjectionService service = (InjectionService)context.getBean(\"injectionService\"); service.save(\"这是要被保存的数据\"); } } 测试结果： log4j:WARN No appenders could be found for logger (org.springframework.core.env.StandardEnvironment). log4j:WARN Please initialize the log4j system properly. Service接收参数：这是要被保存的数据 保存数据：这是要被保存的数据:1177377518 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/spring/bean.html":{"url":"pages/spring/bean.html","title":"Bean装配","keywords":"","body":"Bean装配 Bean配置项 Bean的作用域 Bean的生命周期 Bean的自动装配 Resources & ResourceLoader Bean配置项 常用配置项 说明 id bean的唯一标识 class 具体要实例化的哪一个类 scope 作用域 constructor arguments 构造器参数 properties 属性 autowiring mode 自动装配模式 lazy-initialization mode 懒加载 initialization/destruction method 初始化和销毁的方法 Bean的作用域 作用域 说明 singleton 单列，指一个Bean容器中只存在一份 prototype 每次请求（每次使用）创建新的实例，destroy方式不生效 request 每次http请求创建一个实例，且仅在当前request内有效 session 同时，每次http请求创建，当前session内有效 global session 基于portlet的web中有效（portlet定义了global session），如果是在web中，同session package com.test.bean; public class BeanScope { public void say() { System.out.println(\"BeanScope say: \" + this.hashCode()); } } package com.test.bean; import org.junit.BeforeClass; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class BeanScopeTest { private static ApplicationContext context; @BeforeClass public static void setUpBeforeClass() throws Exception { context = new ClassPathXmlApplicationContext(\"bean-scope.xml\"); } @Test public void testSay() { BeanScope beanScope = (BeanScope) context.getBean(\"beanScope\"); beanScope.say(); BeanScope beanScope2 = (BeanScope) context.getBean(\"beanScope\"); beanScope2.say(); } } singleton结果： BeanScope say: 951880373 BeanScope say: 951880373 prototype结果： BeanScope say: 1045941616 BeanScope say: 161960012 实例代码见：codes/spring-bean-scope Bean的生命周期 定义、初始化、使用、销毁 [!TIP|style:flat|label:初始化的两种方式] 实现org.springframework.beans.factory.InitializingBean接口，覆盖afterPropertiesSet方法 配置init-method 覆盖afterPropertiesSet方法 public class ExampleInitializingBean implements InitializingBean { @Override public void afterPropertiesSet() throw Exception { // do something } } 配置init-method public class ExampleBean { public void init() { // do some initialization work } } [!TIP|style:flat|label:销毁的两种方式] 实现org.springframework.beans.factory.DisposableBean接口，覆盖destroy方法 配置destroy-method 覆盖destroy方法 public class ExampleDisposableBean implements DisposableBean { @Override public void destroy() throw Exception { // do something } } 配置destroy-method public class ExampleBean { public void cleanup() { // do some destruction work (like releasing pooled connections) } } 配置全局默认初始化、销毁方法 package com.test.bean; public class BeanLifeCycle { public BeanLifeCycle() { // do } public void init() { System.out.println(\"BeanLifeCycle init\"); } public void destroy() { System.out.println(\"BeanLifeCycle destroy\"); } } package com.test.bean; import org.junit.After; //import org.junit.Before; import org.junit.BeforeClass; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.BlockJUnit4ClassRunner; import org.springframework.beans.BeansException; import org.springframework.context.support.ClassPathXmlApplicationContext; @RunWith(BlockJUnit4ClassRunner.class) public class BeanLifeCycleTest { private static ClassPathXmlApplicationContext context; @BeforeClass public static void setUpBeforeClass() throws Exception { try { context = new ClassPathXmlApplicationContext(\"bean-lifecycle.xml\"); context.start(); } catch(BeansException e) { e.printStackTrace(); } } // @Before // public void before() throws Exception { // try { // context = new ClassPathXmlApplicationContext(\"bean-lifecycle.xml\"); // context.start(); // } catch(BeansException e) { // e.printStackTrace(); // } // } @After public void after() throws Exception { context.destroy(); } @Test public void test() { context.getBean(\"beanLifeCycle\"); } } 运行结果： 七月 15, 2019 3:14:15 下午 org.springframework.context.support.AbstractApplicationContext prepareRefresh 信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@1c2c22f3: startup date [Mon Jul 15 15:14:15 JST 2019]; root of context hierarchy 七月 15, 2019 3:14:15 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions 信息: Loading XML bean definitions from class path resource [bean-lifecycle.xml] BeanLifeCycle init 七月 15, 2019 3:14:15 下午 org.springframework.context.support.AbstractApplicationContext doClose 信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@1c2c22f3: startup date [Mon Jul 15 15:14:15 JST 2019]; root of context hierarchy BeanLifeCycle destroy 覆盖destroy方法 && 覆盖afterPropertiesSet方法 package com.test.bean; import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean; public class BeanLifeCycleOverride implements InitializingBean, DisposableBean { @Override public void afterPropertiesSet() { System.out.println(\"BeanLifeCycleOverride: afterPropertiesSet\"); } @Override public void destroy() { System.out.println(\"BeanLifeCycleOverride: destroy\"); } } 结果： 信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@1c2c22f3: startup date [Mon Jul 15 15:46:16 JST 2019]; root of context hierarchy 七月 15, 2019 3:46:16 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions 信息: Loading XML bean definitions from class path resource [bean-lifecycle-override.xml] BeanLifeCycleOverride: afterPropertiesSet 七月 15, 2019 3:46:16 下午 org.springframework.context.support.AbstractApplicationContext doClose 信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@1c2c22f3: startup date [Mon Jul 15 15:46:16 JST 2019]; root of context hierarchy BeanLifeCycleOverride: destroy 同时使用全局和单个bean的init、destroy属性 package com.test.bean; import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean; public class BeanLifeCycleOverride implements InitializingBean, DisposableBean { public void defaultInit() { System.out.println(\"Bean defaultInit\"); } public void defaultDestroy() { System.out.println(\"Bean defaultDestroy\"); } @Override public void afterPropertiesSet() { System.out.println(\"BeanLifeCycleOverride: afterPropertiesSet\"); } @Override public void destroy() { System.out.println(\"BeanLifeCycleOverride: destroy\"); } public void start() { System.out.println(\"BeanLifeCycle init\"); } public void stop() { System.out.println(\"BeanLifeCycle destroy\"); } } package com.test.bean; import org.junit.After; import org.junit.BeforeClass; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.BlockJUnit4ClassRunner; import org.springframework.beans.BeansException; import org.springframework.context.support.ClassPathXmlApplicationContext; @RunWith(BlockJUnit4ClassRunner.class) public class BeanLifeCycleTest { private static ClassPathXmlApplicationContext context; @BeforeClass public static void setUpBeforeClass() throws Exception { try { context = new ClassPathXmlApplicationContext(\"bean-lifecycle-multiple.xml\"); context.start(); } catch(BeansException e) { e.printStackTrace(); } } @After public void after() throws Exception { context.destroy(); } @Test public void test() { context.getBean(\"beanLifeCycle\"); } } 运行结果： 七月 15, 2019 4:00:04 下午 org.springframework.context.support.AbstractApplicationContext prepareRefresh 信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@1c2c22f3: startup date [Mon Jul 15 16:00:04 JST 2019]; root of context hierarchy 七月 15, 2019 4:00:04 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions 信息: Loading XML bean definitions from class path resource [bean-lifecycle-multiple.xml] BeanLifeCycleOverride: afterPropertiesSet BeanLifeCycle init 七月 15, 2019 4:00:04 下午 org.springframework.context.support.AbstractApplicationContext doClose 信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@1c2c22f3: startup date [Mon Jul 15 16:00:04 JST 2019]; root of context hierarchy BeanLifeCycleOverride: destroy BeanLifeCycle destroy [!WARNING|style:flat|label:注意] 默认的default-init(destroy)-method配置未生效。 Aware接口 Spring中提供了一些以Aware结尾的接口，实现了Aware接口的bean在被初始化之后，可以获取相应资源 通过Aware接口，可以对Spring相应资源进行操作（一定要慎重） 为对Spring进行简单的扩展提供了方便的入口 Name Injected Dependency ApplicationContextAware Declaring ApplicationContext ApplicationEventPubilsherAware BeanClassLoaderAware BeanFactoryAware BeanNameAware Name of the declaring bean BootstrapContextAware LoadTimeWeaverAware ServletConfigAware ServletContextAware Bean的自动装配 Resources & ResourceLoader © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/spring/aspect-oriented-programming.html":{"url":"pages/spring/aspect-oriented-programming.html","title":"AOP基本概念","keywords":"","body":"© 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/spring/aop-api.html":{"url":"pages/spring/aop-api.html","title":"AOP的API介绍","keywords":"","body":"© 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/spring/aspect-j.html":{"url":"pages/spring/aspect-j.html","title":"Spring对AspectJ的支持","keywords":"","body":"© 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/spring-mvc/":{"url":"pages/spring-mvc/","title":"Spring MVC起步","keywords":"","body":"Spring MVC起步 Font Controller分发调度 Controller 业务数据抽取 View template 页面呈现 MVC的核心思想是业务数据抽取同业务数据呈现相分离 MVC Model-View-Controller 视图层为用户提供UI，重点关注数据的呈现 模型层业务数据的信息表示，关注支持的信息构成，通常是多个业务实体的组合。 控制层调用业务逻辑产生合适的数据(Model)传递给视图层用于呈现 [!TIP|style:flat|label:MVC] MVC是一种架构模式 程序分层，分工合作，既相互独立，又协同工作。 MVC是一种思考方式 需要将什么信息展示给用户？如何布局？调用哪些业务逻辑？ Spring MVC静态概念 DispatcherServlet Controller HandlerAdapter：DispatcherServlet内部使用类，就是Controller的一个表现形式 adapter 英 [əˈdæptə] 美 [əˈdæptər] n.(电器设备的)转接器，适配器;改编者;改写者 扩展阅读：适配器模式 https://blog.csdn.net/zxt0601/article/details/52848004 HandlerInterceptor HandlerMapping 告诉Controller用哪一个Controller1来响应请求 HandlerExecutionChain 内部实现使用的是Java的反射机制 ModelAndView model的具体表现 ViewResolver 视图解析器，通知Dispatcher使用哪个视图来呈现；作用：根据我们的配置，找出对应的视图对象 View Spring MVC动态概念 Maven 搭建Spring MVC项目开发环境 POM(Project Object Model) 配置依赖管理、生命周期、依赖需要等，dependencies, developers, organization, licenses ... ... https://maven.apache.org/ref/3.6.1/maven-model/maven.html Dependency Management 依赖 junit junit ${junit.version} test org.springframework spring-webmvc org.codehaus.jackson jackson-mapper-asl ${jackson.version} Coordinates 坐标 四个属性：groupId, artifactId, version, packaging(默认值jar)，通过这四个属性就可以标识唯一的一个坐标?? 安装Maven 下载并解压Maven https://maven.apache.org/download.cgi 配置环境变量(M2_HOME, Path) 拷贝conf/setting.xml到user/.m2/目录中 根据需要修改setting.xml /path/to/local/repo --> UK UK Central http://uk.maven.org/maven2 central 配置Maven配置文件(本地仓库路径，镜像) Eclipse集成Maven(下载eclipse kepler自带m2e) # 创建目录结构 mvn archetype:generate -DgroupId=test-java-maven -DartifactId=spring-mvc-demo1 -DarchetypeArtifactId=maven-archetype-webapp Eclipse导入通过命令创建的项目： 修改pom.xml 4.0.0 test-java-maven spring-mvc-demo1 jar 1.0-SNAPSHOT spring-mvc-demo1 Maven Webapp http://maven.apache.org 2.6 1.7.6 4.1.3.RELEASE org.springframework spring-framework-bom ${spring.version} pom import org.springframework spring-webmvc commons-lang commons-lang ${commons-lang.version} org.slf4j slf4j-log4j12 ${slf4j.version} slf4j-api org.slf4j junit junit 3.8.1 test --> spring-mvc-demo1 org.eclipse.jetty jetty-maven-plugin 9.2.20.v20161216 修改web.xml Archetype Created Web Application mvc-dispatcher org.springframework.web.servlet.DispatcherServlet contextConfigLocation /WEB-INF/configs/spring/mvc-dispatcher-servlet.xml 1 mvc-dispatcher / 创建/WEB-INF/configs/spring/mvc-dispatcher-servlet.xml 创建/spring-mvc-demo1/src/main/webapp/WEB-INF/jsps/home.jsp Insert title here Hello Spring MVC! 创建/spring-mvc-demo1/src/main/java/com/test/mvcdemo/controller/HelloMVCController.java package com.test.mvcdemo.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/hello\") public class HelloMVCController { @RequestMapping(\"/mvc\") // 该方法会响应请求host:8080/hello/mvc // 返回到home.jsp public String helloMVC() { // 返回到home.jsp return \"home\"; } } 运行项目 mvn jetty:run 如果报错，需要检查和修改响应错误配置。 如果一切顺利，以下页面就能正常访问： http://localhost:8080/hello/mvc 资源 https://www.imooc.com/learn/47 https://maven.apache.org/ © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/spring-mvc/hands-on.html":{"url":"pages/spring-mvc/hands-on.html","title":"Spring MVC实操","keywords":"","body":"Spring MVC实操 从配置文件开始 src/main/webapp/WEB-INF/web.xml --> Spring MVC DEMO contextConfigLocation /WEB-INF/configs/spring/applicationContext*.xml org.springframework.web.context.ContextLoaderListener mvc-dispatcher org.springframework.web.servlet.DispatcherServlet contextConfigLocation /WEB-INF/configs/spring/mvc-dispatcher-servlet.xml 1 mvc-dispatcher / Spring MVC的上下文层级 src/main/webapp/WEB-INF/configs/spring/mvc-dispatcher-servlet.xml 3中不同形式编写Controller类 package com.test.mvcdemo.controller; import java.util.Map; import javax.servlet.http.HttpServletRequest; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import com.test.mvcdemo.model.Course; import com.test.mvcdemo.service.CourseService; @Controller @RequestMapping(\"/courses\") // /courses/* public class CourseController { private static Logger log = LoggerFactory.getLogger(CourseController.class); private CourseService courseService; @Autowired public void setCourseServiceImpl(CourseService courseService) { this.courseService = courseService; } // 本方法仅处理 /course/view?courseId=123 @RequestMapping(value=\"/view\", method=RequestMethod.GET) public String viewCourse(@RequestParam(\"courseId\") Integer courseId, Model model) { log.debug(\"In viewCourse, courseId = {}\", courseId); Course course = courseService.getCourseById(courseId); model.addAttribute(course); // 返回jsp的文件名 return \"course-overview\"; } // /courses/view2/{courseId} @RequestMapping(value=\"/view2/{courseId}\", method=RequestMethod.GET) public String viewCourse2(@PathVariable(\"courseId\") Integer courseId, Map model) { log.debug(\"In viewCourse2, courseId = {}\", courseId); Course course = courseService.getCourseById(courseId); model.put(\"course\", course); return \"course-overview\"; } // /course/view?courseId=333 @RequestMapping(\"view3\") public String viewCourse3(HttpServletRequest request) { Integer courseId = Integer.valueOf(request.getParameter(\"courseId\")); Course course = courseService.getCourseById(courseId); request.setAttribute(\"course\", course); return \"course-overview\"; } } [!TIP|style:flat|label:总结] 通过@Controller声明一个Controller 通过@RequestMapping 映射URL和方法，通常出现在我们的类级别和方法级别，二者组合完成了对URL映射请求的拦截 通过URL template(@RequestParam and @PathVariable)将URL中的参数，绑定到Controller中method的入参 同时也可以通过HTTPServletRequest and/or HttpSession等对象来获取我们想要的结果 Binding 数据绑定 将请求中的字段按照名字匹配的原则填入模型对象。 // CourseController.java @RequestMapping(value=\"/admin\", method=RequestMethod.GET, params=\"add\") public String createCourse() { return \"admin/edit\"; } // 接收处理表单数据 @RequestMapping(value=\"/save\", method=RequestMethod.POST) // public String doSave(Course course) { public String doSave(@ModelAttribute Course course) { log.debug(\"Info of Course\"); log.debug(ReflectionToStringBuilder.toString(course)); System.out.println(course.toString()); // 在此进行业务操作，比如数据库持久化 course.setCourseId(555); return \"redirect:view2/\" + course.getCourseId(); } [!TIP|style:flat|label:总结] 在Controller参数上，使用@ModelAttribute实现模型与页面数据的绑定，及如果在MVC中使用重定向或转发redirect/forward FileUpload 单文件上传 src/main/webapp/WEB-INF/configs/spring/mvc-dispatcher-servlet.xml /pom.xml commons-fileupload commons-fileupload 1.3.3 commons-io commons-io 2.6 admin/file.jsp /courses/do-upload\" method=\"post\" enctype=\"multipart/form-data\"> 文件上传 上传 Controller.java @RequestMapping(value=\"/upload\", method=RequestMethod.GET) public String showUploadPage() { return \"admin/file\"; } @RequestMapping(value=\"/do-upload\", method=RequestMethod.POST) public String doUploadFile(@RequestParam(\"file\") MultipartFile file) throws IOException { if (!file.isEmpty()) { FileUtils.copyInputStreamToFile(file.getInputStream(), new File(\"D:/java/temp\", System.currentTimeMillis() + \"_\" + file.getOriginalFilename())); } return \"home\"; } JSON JSON (JavaScript Object Notation) is a lightweight data-interchange format 相同数据，不同呈现方式。JSPView, JsonView ContentNegotiatingViewResolver 配置文件：src/main/webapp/WEB-INF/configs/spring/mvc-dispatcher-servlet.xml 添加依赖：/pom.xml 2.9.9.1 com.fasterxml.jackson.core jackson-databind ${jackson.version} src/main/java/com/test/mvcdemo/controller/CourseController.java @RequestMapping(value=\"/{courseId}\", method=RequestMethod.GET) public @ResponseBody Course getCourseInJson(@PathVariable Integer courseId) { return courseService.getCourseById(courseId); } @RequestMapping(value=\"/json/{courseId}\", method=RequestMethod.GET) public ResponseEntity getCourseInJson2(@PathVariable Integer courseId) { Course course = courseService.getCourseById(courseId); return new ResponseEntity(course, HttpStatus.OK); } 总结 Work with JSON ContentNegotiatingViewResolver ResponseEntity @ResponseBody/@RequestBody @RequestBody的使用 Details 源码 codes/spring-mvc-demo1 扩展阅读 @RequestBody的使用 https://blog.csdn.net/justry_deng/article/details/80972817 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/spring-mvc/interceptor.html":{"url":"pages/spring-mvc/interceptor.html","title":"Spring MVC拦截器","keywords":"","body":"拦截器 interceptor 英 [ˌɪntəˈseptə(r)] 美 [ˌɪntərˈseptər] n.截击机，拦截器 [!TIP|style:flat|label:Interceptor] 拦截器是指通过统一拦截从浏览器发往服务器的请求来完成功能的增强。(相当于Node.js KOA2的中间件) 使用场景：解决请求的共性问题（如：乱码问题、权限验证问题等） 拦截器的基本工作原理 SpringMVC可以通过配置过滤器来解决乱码问题 拦截器的工作原理和过滤器非常相似 过滤器 src/main/webapp/WEB-INF/web.xml viewSpace org.springframework.web.servlet.DispatcherServlet viewSpace *.form --> / encoding org.springframework.web.filter.CharacterEncodingFilter encoding utf8 encoding * 拦截器实现 编写拦截器类实现HandlerInterceptor接口 将拦截器注册进SpringMVC框架中 配置拦截器规则 src/main/webapp/WEB-INF/viewSpace-servlet.xml // 编写拦截器类实现HandlerInterceptor接口 package com.zx.interceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; public class ZxInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"进入了preHandle\"); return true; } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"进入了postHandle\"); } public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"进入了afterCompletion\"); } } 结果： 进入了preHandle 进入了控制器view()方法... name = null pwd = null 进入了postHandle 进入了afterCompletion 拦截器方法介绍 preHandle 在请求被处理之前进行调用；返回 false，请求将被终止。 postHandle 在请求被处理之后进行调用。可以在此方法中修改数据等操作。 afterCompletion 在请求结束之后调用。可以在此做一些资源释放等操作。 src/main/java/com/zx/interceptor/ZxInterceptor.java package com.zx.interceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; public class ZxInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"进入了preHandle\"); // 解决乱码问题 // request.setCharacterEncoding(\"utf-8\"); // 解决权限验证问题 if (request.getSession().getAttribute(\"user\") == null) { // 如果用户没有登录，就终止请求 // 并跳转只登录页面 request.getRequsetDispatcher(\"/login.jsp\").forward(request, response); return false; } return true; } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"进入了postHandle\"); modelAndView.addObject(\"name\", \"这里获取到的是被拦截器postHandle方法修改后的数据。\"); } public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"进入了afterCompletion\"); } } src/main/java/com/zx/interceptor/controller/ZxInterceptorController.java package com.zx.interceptor.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.servlet.ModelAndView; @Controller @RequestMapping(\"/\") public class ZxInterceptorController { // localhost:8080/view?name=测试&pwd=456799 @RequestMapping(\"/view\") public ModelAndView view(String name, String pwd) { ModelAndView mv = new ModelAndView(); System.out.println(\"进入了控制器view()方法...\"); System.out.println(\"name = \" + name); System.out.println(\"pwd = \" + pwd); mv.setViewName(\"index.jsp\"); mv.addObject(\"name\", name); mv.addObject(\"password\", pwd); return mv; } } src/main/webapp/index.jsp Hello World! ${name}, ${password} 多个拦截器配置 工作流程： 拦截器的其他实现方法 拦截器的类通过实现WebRequestInterceptor接口来编写。 配置文件SpringMVC框架注册写法不变。 缺点：preHandle方法没有返回值，不能终止请求。 src/main/java/com/zx/interceptor/ZxInterceptor2.java package com.zx.interceptor; import org.springframework.ui.ModelMap; import org.springframework.web.context.request.WebRequest; import org.springframework.web.context.request.WebRequestInterceptor; public class ZxInterceptor2 implements WebRequestInterceptor { public void preHandle(WebRequest request) throws Exception { // TODO Auto-generated method stub } public void postHandle(WebRequest request, ModelMap model) throws Exception { // TODO Auto-generated method stub } public void afterCompletion(WebRequest request, Exception ex) throws Exception { // TODO Auto-generated method stub } } 拦截器的使用场景 使用原则：处理所有请求的共同问题 解决乱码问题 解决权限验证问题 拦截器和过滤器区别 过滤器Filter依赖于Servlet容器，基于回调函数，过滤范围大。 拦截器Interceptor依赖于框架容器，基于反射机制，只过滤请求。 总结 拦截器可以处理Web应用中请求的一些通用性问题。 共性问题在拦截器中处理，可以减少重复代码，便于维护。 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/java-web/":{"url":"pages/java-web/","title":"JavaWeb应用程序","keywords":"","body":"Java Web 应用程序 Web应用程序 Web应用程序开发，是目前软件开发领域三大方向之一。 桌面应用程序：QQ、Office等 Web应用程序：京东、天猫等 嵌入式应用程序：安卓、iPhone JavaEE方向需求一直较大，也就是就业比较容易和稳定。 静态网页与动态网页 静态网页 表现形式：网页中的内容是固定的，不能自动更新 所需技术：HTML、CSS 动态网页 网页中内容通过程序动态显示，自动更新。 所需技术：HTML、CSS，数据库技术、至少一门高级语言（Java、C#、PHP、Python、GoLang、Node.js、C++等）、JavaScript、XML等。主流的动态网页脚本技术Jsp、Asp.net、Php等 开发环境 JDK7.0+ Tomcat7.0+ [!TIP|style:flat|label:Tomcat服务器简介] Apache Jakarta的开源项目 JSP/Servlet容器 安装步骤：下载-解压-配置环境变量(CATALINA_HOME)-测试首页(http://localhost:8080) Tomcat服务器目录结构： MyEclipse or eclipse手动编写第一个Web程序，步骤： 1.在Tomcat WebApps中创建项目目录 2.编写index.jsp 3.创建WEB-INF目录 4.测试运行 [!TIP|style:flat|label:WEB-INF目录结构：] WEB-INF是Java web应用的安全目录。所谓安全就是客户端无法访问，只有服务端代码可以访问的目录。 web.xml，项目部署配置文件 classes文件夹，用于存放*.class文件。 lib文件夹，用于存放需要的jar包。 # /tomcat9/webapps/examples/WEB-INF /classes 编译生成的字节码文件 /jsp /jsp2 /lib 项目需要用的一些java包 /tags web.xml [!TIP|style:flat|label:MyEclipse与Eclipse] MyEclipse 收费，继承了很多收费的插件，比如SSH、安卓等 Eclipse 免费开源，不包含任何附加功能的插件 MyEclipse 配置JRE： # 软件菜单栏 windows -> Preference -> Java -> Installed JREs # 自定义JDK，默认为1.6 Add... -> Standard VM -> JDK安装目录 -> 勾选并确定 MyEclipse集成Tomcat服务器 # 软件菜单栏 Windows -> Preference -> MyEclipse -> Servers -> Tomcat # 选择Tomcat服务器 Tomcat 7.x -> Enable -> Brower -> Tomcat安装目录 # 展开Tomcat 7.x JDK -> 选择自己安装的JDK 创建Web项目 New -> Web Project -> Project Name: Test0703 发布代码 点击发布按钮 -> 选择发布服务器 -> 启动服务器 # 浏览器中访问项目 http://localhost:8080/Test0703 # 注意名称大小写 Web项目目录结构 项目的虚拟路径：默认与项目名称相同 右键单击项目根目录名称 -> Properties Eclipse 创建一个动态web项目(Eclipse Jee 2018-12) project name, and Runtime... Run as 修改Tomcat默认端口 tomcat9/conf/server.xml 参考资料 https://www.imooc.com/learn/166 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/java-web/jsp.html":{"url":"pages/java-web/jsp.html","title":"JSP基本语法","keywords":"","body":"Jsp基本语法 [!TIP|style:flat|label:JSP（Java Server Pages] 其根本是一个简化的Servlet设计，他实现了在Java当中使用HTML标签。 JSP是一种动态网页技术标准，也是JavaEE的标准。 JSP与Servlet一样，是在服务器端执行的。 名称 说明 Jsp Java平台，安全性高，适合开发大型、企业级的Web应用程序。 Asp.net .Net平台，简单易学。但是安全性以及跨平台性差。 PHP 简单、高效，成本低开发周期短，特别适合中小型企业的Web应用开发。 JSP页面元素构成 JSP指令 指令 说明 page指令 通常位于JSP页面的顶端，同一个页面可以多个page指令。 include指令 将一个外部文件嵌入到当前JSP文件中，同时解析这个页面中的JSP语句。 taglib指令 使用标签库定义新的自定义标签，在JSP页面中启用定制行为。 page指令语法 常用属性 描述 默认值 language 指定JSP页面使用的脚本语言 java import 通过该属性来引用脚本语言中使用到的类文件 无 contentType 原来指定JSP页面所采用的编码方式看，文件类型等 text/html,ISO-8856-1 JSP注释 html的注释： JSP的注释： JSP脚本注释： JSP脚本 在JSP页面中执行的java代码。 语法： JSP声明 在JSP页面中定义变量或方法。 语法： JSP表达式 在JSP页面中执行的表达式。 语法： 注意：表达式不以分号结束。 测试str变量输出： add方法输出：10 + 20 = JSP生命周期 jspService()方法被调用来处理客户端的请求。对每一个请求，JSP引擎创建一个新的线程来处理该请求。 如果有多个客户端同时请求该JSP文件，则JSP引擎会创建多个线程，每个客户端请求对应一个线程。以多线程方式执行可以大大降低对系统的资源需求，提高系统的并发量及响应时间。但也要注意多线程的编程带来的同步问题，比如资源共享，线程安全等。由于该Servlet始终驻于内存，所以响应是非常快的。 # 生成的字节码文件目录 /tomcatx.x/work/Catalina/localhost/MyEclipseTest090301 [!WARNING|style:flat|label:练习] 当用户第一次请求一个jsp页面时，首先被执行的方法是(A) A. 构造方法 B. jspInit() C. jspService() D. jspDestroy() codes/first-eclipse-web-project/ 练习 输出99乘法表： \"; } return str; } // 脚本方式 void printMT(JspWriter out) throws Exception { for (int i = 1; i \"); } } %> 表达式方式： 脚本方式： © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/java-web/built-in-object.html":{"url":"pages/java-web/built-in-object.html","title":"JSP内置对象out, request, response, session, application...","keywords":"","body":"JSP内置对象 内置对象简介 四种作用域范围 out request/response session application 其它内置对象 项目案例 内置对象简介 是Web容器创建的一组对象，不使用new关键字就可以使用的内置对象。 [!TIP|style:flat|label:JSP九大内置对象] 常用内置对象： out, request, response, session, application 其它内置对象 page, pageContext, exception, config Web程序的请求响应模式： 用户发送请求(request)，服务器给用户响应(response)。 什么是缓冲区 缓冲区(Buffer)，所属缓冲区就是内存的一块区域，用来保存临时数据。 out对象 是JspWriter类的实例，是向客户端输出内容常用的对象。 常用方法 说明 void println() 向客户端打印字符串。 void clear() 清除缓冲区的内容。注意，如果在flush之后调用会抛出异常。 void clearBuffer() 清除缓冲区的内容，不会向客户端输出任何内容。在flush之后调用不会抛出异常。 void flush() 将缓冲区内容输出到客户端。 int getBufferSize() 获取缓冲区字节数的大小，如不设置缓冲区则为0。 int getRemaining() 获取缓冲区剩余可用字节大小（可用空间）。 boolean isAutoFlush() 返回缓冲区满时，是自动清空还是抛出异常。 void close() 关闭输出流。 out内置对象 静夜思\"); out.println(\"床前明月光\"); out.println(\"疑是地上霜\"); out.println(\"举头望明月\"); out.println(\"低头思故乡\"); %> 缓冲区大小：byte 缓冲区剩余空间：byte 是否自动清空缓冲区： 结果： 静夜思 床前明月光 疑是地上霜 举头望明月 低头思故乡 缓冲区大小：8192byte 缓冲区剩余空间：7513byte 是否自动清空缓冲区：true 使用 out.flush() out内置对象 静夜思\"); out.println(\"床前明月光\"); out.flush(); out.println(\"疑是地上霜\"); out.println(\"举头望明月\"); out.println(\"低头思故乡\"); %> 缓冲区大小：byte 缓冲区剩余空间：byte 是否自动清空缓冲区： 结果：注意缓冲区剩余空间的值 静夜思 床前明月光 疑是地上霜 举头望明月 低头思故乡 缓冲区大小：8192byte 缓冲区剩余空间：8126byte 是否自动清空缓冲区：true get 与 post get 以明文的方式，通过URL提交数据，数据在URL中可以看到。提交的数据最多不超过2KB。安全性较低但效率比post高。适合提交数据量不大，安全性不高德数据。比如：搜索、查询等功能。 post 将用户提交的数据封装在HTML HEADER内。适合提交数据量大，安全要求高德用户信息。比如注册、修改、上传等功能。 GET 用户名: 密 &nbsp;&nbsp;码: POST 用户名: 密 &nbsp;&nbsp;码: request对象 [!TIP|style:flat|label:request对象] 客户端的请求信息被封装在request对象中，通过它才能了解到客户端的需求，然后做出响应。 它是HttpServletRequest类的实例。 具有请求域，即完成客户端的请求之前，该对象一直有效。 常用方法如下： String getParameter(String name) 返回name指定参数的值，即获取单个值。 String[] getParameterValues(String name) 返回包含参数name的所有值得数组，即获取所有参数的集合。 void setAttribute(String name, Object obj); 存储此请求中的属性。 Object getAttribute(String name) 返回指定属性的属性值。 String getContentType() 得到请求体的MIME类型。 String getProtocol() 获取请求用的协议类型及版本号。 String getServerName() 返回接受请求的服务器主机名。 setCharacterEncoding(\"utf-8\") 设置字符集编码格式，可用于解决中文乱码问题。 注册 用户名: 读书 写字 看电影 音乐 跑步 旅游 测试URL传参 regdo.jsp 用户名： 爱好： [!WARNING|style:flat|label:注意] 通过URL传参中文乱码问题，可以在tomcat/conf/server.xml中设置编码。 其他方法及结果： # 方法 结果 # 获取请求体MIME类型 getContentType null # 协议及版本 getProtocol HTTP/1.1 # 服务器主机名 getServerName localhost # 服务器端口号 getServerPort 8080 # 请求文件长度 getContentLength -1 # 请求客户端的IP地址 getRemoteAddr 0:0:0:0:0:0:0:1 # 请求文件真实路径 getRealPath D:\\Java\\tomcat9\\webapps\\www\\index.jsp # 请求上下文路径 getContextPath /www # getScheme http response对象 [!TIP|style:flat|label:response对象] response对象包含了响应客户端请求的相关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。 response对象具有页面作用域，即访问一个页面时，该页面内的response对象只能对这次访问有效。其他页面的response对象对当前页面无效。 常用方法： String getCharacterEncoding() 返回响应应用的是何种字符编码 void setContentType(String type) 设置响应的MIME类型 PrintWriter getWriter() 返回可以向客户端输出字符的一个对象（注意比较PrintWriter与内置out对象的区别） [!WARNING|style:flat|label:区别] PrintWriter outer = response.getWriter(); 默认情况下，outer.println()该对象输出的内容，总是在内置对象out.println()之前。 可以通过 out.flush() 方法，实现按文档流输出。（见代码部分） sendRedirect(java.lang.String location) 重新定向客户端的请求 response.jsp response内置对象\"); out.println(\"\"); PrintWriter outer = response.getWriter(); outer.println(\"这是response.getWriter()对象输出流\"); %> 结果： 这是response.getWriter()对象输出流 response内置对象 通过 out.flush() 方法，实现按文档流输出 response内置对象\"); out.println(\"\"); out.flush(); PrintWriter outer = response.getWriter(); outer.println(\"这是response.getWriter()对象输出流\"); %> 结果： response内置对象 这是response.getWriter()对象输出流 请求重定向和请求转发 名称 区别 请求重定向 客户端行为，response.sendRedirect()，从本质将等同于两次请求。前一次的请求对象不会保存，地址栏的URL会改变为定向地址。 请求转发 服务器行为，request.getRequestDispatcher().forward(req, res)。是一次请求，转发后请求对象会保存，URL地址不会改变。 session [!TIP|style:flat|label:session] session表示客户端与服务端的一次会话。 Web中的session指的是用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。 从上述定义中可以看到，session实际上是一个特定的时间概念。 在服务器内存中，保存着不同用户(客户端)的session。即session存在于服务器内存中。 在服务器内存中，保存着不同用户的session。 [!NOTE|style:flat|label:session对象] 是一个JSP内置对象 在第一个JSP页面被装载时自动创建，完成会话期管理。 从一个客户打开浏览器并连接到服务器开始，到客户关闭浏览器离开这个服务器结束，被称为一个会话。 当一个客户访问一个服务器时，可能会在服务器的几个页面之间切换，服务器应当通过某种办法知道这是一个客户，就需要session对象。 session对象时HttpSession类的实例 session对象常用方法： long getCreationTime() 返回SESSION创建时间（单位毫秒） public String getId() 返回SESSION创建时JSP引擎为它设的唯一ID值 public Object setAttribute(String name, Object value) 使用指定名称将对象绑定到此会话 public Object getAttribute(String name) 返回与此会话中的指定名称绑定在一起的对象，如果没有则返回null String[] getValueNames() 返回一个包含此SESSION中所有可能属性的数组 void setMaxInactiveInterval(int second) 设置SESSION过期时间(单位秒) int getMaxInactiveInterval() 返回两次请求间隔多长时间此SESSION被取消(单位秒)，即SESSION过期时间 session内置对象 getId: Session创建时间：毫秒 时间长度：位 格式化后的时间： 获取自定义属性： 结果： session内置对象 getId: FBBE1BF8A1502240D4DC31EED0BD5EBA Session创建时间：1562411220284毫秒 时间长度：13位 格式化后的时间：2019-07-06 20:07:00 获取自定义属性：master session的生命周期 创建： 客户端第一次访问当前网站某个jsp或Servlet的时候，服务器会为当前会话创建一个SessionId。客户端每次向服务器发送请求时，都会带上此SessionId，服务器端会对该SessionId进行校验。 活动： 某次会话当中，通过超链接打开的同域新页面，则属于同一次会话。 只要当前会话页面没有全部关闭，重新打开新的浏览器窗口访问同一个项目资源时属于同一次会话。 除非本次会话的所有页面都关闭后，再重新访问某个Jsp或者Servlet将会创建新的会话。 注意：旧的Session仍然存在于服务器内存当中 销毁： Session的销毁有3种方式： 调用session.invalidate()方法 Session过期 服务器重启（？相当于清空内存） Tomcat web.xml中配置过期时间：(默认为30分钟) 30 application [!TIP|style:flat|label:application] application对象实现了用户间数据的共享，可以存放全局变量 application开始于服务器的启动，终止于服务器的关闭 在用户的前后连接或不同用户之间的连接中，可以对application对象的同一属性进行操作。 在任何地方对application对象属性的操作，都将影响到其他用户对此的访问。 服务器的启动和关闭决定了application对象的生命周期 application对象是ServletContext类的实例 常用方法 public void setAttribute(String name, Object value) 设置属性及值 public Object getAttribute(String name) 获取属性值，无则返回null Enumeration getAttributeNames() 返回所有可用属性名的枚举 String getServerInfo() 返回JSP（Servlet）引擎及版本号 例子： APPLICATION gePROJECT_NAME: 所有属性： getServerInfo： 结果： APPLICATION gePROJECT_NAME: TEST_SERVER 所有属性： javax.servlet.context.tempdir systemEmail org.apache.catalina.resources com.sun.faces.config.WebConfiguration org.apache.tomcat.InstanceManager org.apache.catalina.jsp_classpath org.apache.jasper.compiler.ELInterpreter org.apache.jasper.compiler.TldCache PROJECT_NAME org.apache.tomcat.JarScanner systemName javax.websocket.server.ServerContainer org.apache.jasper.runtime.JspApplicationContextImpl getServerInfo：Apache Tomcat/9.0.20 page对象 page对象就是指当前JSP页面本身，有点像类中的this指针，它是java.lang.Object类的实例。 常用方法 说明 class getClass() 返回Object的类 int hashCode() 返回此Object的hash码 boolean equals(Object obj) 判断此Object是否与指定的Object对象相等 void copy(Object obj) 把此Object拷贝到指定的Object对象中 Object clone() 克隆对象 String toString() 把Object对象转换成String类的对象 void notify() 唤醒一个等待的线程 void notifyAll() 唤醒所有等待的进程 void wait(int timeout) 使一个线程除于等待状态，指定timeout结束，或被唤醒 void wait() 使一个线程处于等待直到被唤醒 pageContext对象 pageContext对象提供了对JSP页面内所有的对象及名字空间的访问 pageContext对象可以访问到本页面所在的session，也可以取本页面所在的application的某一属性值 pageContext对象相当于页面中所有功能的集大成者，即权限较大 pageContext对象的本类名也叫pageContext 常用方法 说明 JspWriter getOut() 返回当前客户端响应被使用的JspWriter流(out) HttpSession getSession() 返回当前页中的HttpSession对象session Object getPage() 返回当前页的Object对象page ServletReuest getRequest() 返回当前页的ServletRequest对象request ServletResponse getResponse() 返回当前页的ServletResponse对象response void setAttribute(String name, Object attr) 设置属性及值 Object getAttribute(String name, int scope) 获取指定范围内的属性值 int getAttributeScope(String name) 返回某属性的作用范围 void forward(String relativeUrlPath) 使当前页面重导到另一个页面 void include(String relativeUrlPath) 在当前位置包含另一个文件 config对象 config对象是一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包含Servlet初始化时所要用到的参数（通过属性名和值构成），以及服务器的有关信息（通过传递一个ServletContext对象）。 常用方法 说明 ServletContext getServletContext() 返回含有服务器相关信息的ServletContext对象 String getInitParameter(String name) 返回初始化参数的值 Enumeration getInitParameterNames() 返回Servlet初始化所需所有参数的枚举 exception对象 exception对象是一个异常对象，当一个页面在运行过程中发生了异常，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。它实际上是java.lang.Throwable的对象，常用方法如下： 常用方法 说明 String getMessage() 返回描述异常的消息 String toString() 返回关于异常的简短描述消息 void printStackTrace() 显示异常及其栈轨迹 Throwable FillInStackTrace() 重写异常的执行栈轨迹 exception-test exception-test.jsp errorPage=\"exception-handler.jsp\"表示页面发生异常时，异常交给 exception-handler.jsp 页面处理。 exception-handler.jsp exception-handler.jsp exception-handler.jsp 异常消息是： toString() 结果： exception-handler.jsp 异常消息是：/ by zero toString() java.lang.ArithmeticException: / by zero 项目案例 模拟登录，登录成功提示“登录成功，用户名为XXX”；登录失败跳转至登录失败页面。 /first-eclipse-web-project/WebContent/login.jsp Login Login 用户 密码 /first-eclipse-web-project/WebContent/do-login.jsp do login © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/java-web/java-bean.html":{"url":"pages/java-web/java-bean.html","title":"JavaBean","keywords":"","body":"JavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。 JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，set和get方法获取。众所周知，属性名称符合这种模式，其他Java 类可以通过自省机制(反射机制)发现和操作这些JavaBean 的属性。 [!TIP|style:flat|label:JavaBeans] 就是符合某种特定的规范的java类。使用JavaBeans的好处是实现代码复用，减少冗余，功能区分明确，提高代码的可维护性。 JavaBean设计原则 // JavaBean设计原则实例：设计学生类 // 1.公有类 public class Students { // 2.属性私有 private String name; private int age; // 3.无参的公共构造方法 public Students() { // constructor } // 4.setter和getter方法 public void setName(String name) { this.name = name; } public String getName() { return this.name; } public void setAge(int age) { this.age = age; } public int getAge() { return this.age; } } Jsp动作元素 JSP动作元素(action elements)为请求处理阶段提供信息。动作元素即标签，遵循XML语法。有一个包含元素名的开始标签，可以有属性、可选的内容、与开始标签匹配的结束标签。 第一类与存取JavaBean有关的，包括： 第二类是JSP1.2就开始有的基本元素，包括6个动作元素 第三类是JSP2.0新增的元素，主要与JSP Document有关，包括6个元素 第四类是JSP2.0新增，主要是用来动态生成XML元素标签的值，包括3个动作 第五类是JSP2.0新增，主要是用在Tag File中，有2个元素 在JSP页面中使用JavaBean 1.像使用普通java一样，创建javabean实例。 src/com.test/Users.java package com.test; public class Users { // private properties private String username; private String password; // constructor public Users() { } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } bean-users.jsp 使用普通方式创建javabean实例 用户名： 密码： 2.在JSP页面中通常使用JSP动作标签使用JavaBean。 useBeans/setProperty/getProperty [!TIP|style:flat|label:useBeans] 作用：在jsp页面中实例化或者在指定范围内使用JavaBean 2.在JSP页面中通常使用JSP动作标签使用JavaBean 用户名： 密码： [!TIP|style:flat|label:setProperty] 作用：给已实例化的JavaBean对象的属性赋值，一共有4种形式。 1.跟表单关联 2.跟表单关联 3.手动设置 4.跟request参数关联 实例1 login.jsp 用户名: 密 &nbsp;&nbsp;码: 1.跟表单关联 do-login.jsp 用户名： 密码： 2.跟表单关联 do-login.jsp 用户名： 密码： 3.手动设置 do-login.jsp 用户名： 密码： 4.跟request参数关联 do-login.jsp?queryUserName=Tom&queryPassWord=999999 用户名： 密码： [!TIP|style:flat|label:getProperty] 作用：获取指定JavaBean对象的属性值。 跟request参数关联 do-login.jsp?queryUserName=Tom&queryPassWord=999999 用户名： 密码： JavaBean的4个作用域 使用useBean的scope属性，可以用来指定JavaBean的作用域。 作用域 说明 page 仅在当前页面有效 request 可以通过HttpRequest.getAttribute() 方法取得JavaBean对象。 session 可以通过HttpSession.getAttribute() 方法获取JavaB对象。 application 可以通过application.getAttribute() 方法取得JavaBean对象 Model 1 Java开发总的方向可以分为Model 1和Model 2。 Model 1 模型出现前，整个Web应用的情况：几乎全部由JSP页面组成，JSP页面接收处理客户端请求，对请求处理后直接作出相应。 弊端：在界面层充斥着大量的业务逻辑代码和数据访问层的代码，Web程序的可扩展性和可维护性非常差。 JavaBean的出现，可以使jsp页面中使用JavaBean封装的数据或者调用JavaBean的业务逻辑代码，这样大大提升了程序的可维护性。 总结 JavaBean就是符合某种设计规范的Java类 在Model 1中，由Jsp页面去调用JavaBean。 JavaBean既可以封装数据，同时也可以封装业务逻辑。 JavaBean一般把属性设计为私有，使用setter和getter访问属性。 实例 使用jsp + JavaBean完成用户登录功能 src/com.dao/UsersDao.java package com.dao; import com.test.Users; public class UsersDao { private String userName = \"admin\"; private String passWord = \"admin\"; // 用户登录验证 public boolean checkLoginUserInfo(Users user) { return userName.equals(user.getUsername()) && passWord.equals(user.getPassword()); } } bean-login.jsp Login 用户名: 密 &nbsp;&nbsp;码: bean-do-login.jsp bean-login-success.jsp Login Success 登录成功 用户名： bean-login-failure.jsp Login Failure 登录失败 -- © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/java-web/state-management.html":{"url":"pages/java-web/state-management.html","title":"Jsp状态管理Cookie","keywords":"","body":"Jsp状态管理 http协议无状态性 保存用户状态的两大机制 Cookie简介 Cookie的创建与使用 Session与Cookie的对比 http协议无状态性 无状态是指，当浏览器发送请求给服务器，服务器响应浏览器请求；但当同一个浏览器再次发送请求给该服务器时，服务器并不知道它就是之前那个浏览器；简单讲就是服务器不会去记得你，所以就是无状态协议。 保存用户状态的两大机制 Session Cookie Cookie简介 [!TIP|style:flat|Cookie] Cookie（译：小甜饼），是Web服务器保存在客户端的一系列文本信息。 典型应用：判断注册用户是否已经登录网站；购物车的处理等。 作用： 对特定对象的追踪；保存用户网页浏览记录与习惯；简化登录... 安全风险：容易泄露用户信息 Cookie的创建与使用 创建Cookie对象： Cookie cookie = new Cookie(String key, Object value); 写入Cookie对象： response.addCookie(cookie); 读取Cookie对象： Cookie[] cookie = request.getCookies(); 常用方法 说明 void setMaxAge(int expiry) 设置cookie的有效期，以秒为单位 void setValue(String value) 在cookie创建后，对cookie进行赋值 String getName() 获取cookie的名称 String getValue() 获取cookie的值 int getMaxAge() 获取cookie的有效时间，单位秒 实例：实现记忆用户名和密码功能 cookie-login.jsp Cookie Login 登录 0) { for (Cookie c:cookies) { if (c.getName().equals(\"username\")) { username = URLDecoder.decode(c.getValue(), \"utf-8\"); } if (c.getName().equals(\"password\")) { password = URLDecoder.decode(c.getValue(), \"utf-8\"); } } } %> 用户名：\"> 密 码：\"> 十天内保存登录状态 cookie-do-login.jsp Cookie Logged 登录成功 0) { String username = URLEncoder.encode(request.getParameter(\"username\"), \"utf-8\"); String password = URLEncoder.encode(request.getParameter(\"password\"), \"utf-8\"); // 保存用户信息 Cookie usernameCookie = new Cookie(\"username\", username); Cookie passwordCookie = new Cookie(\"password\", password); // 保存时间10天 usernameCookie.setMaxAge(864000); passwordCookie.setMaxAge(864000); response.addCookie(usernameCookie); response.addCookie(passwordCookie); } else { Cookie[] cookies = request.getCookies(); if (cookies != null && cookies.length > 0) { for (Cookie c:cookies) { if (c.getName().equals(\"username\") || c.getName().equals(\"password\")) { // 设置cookie失效 c.setMaxAge(0); // 重新保存 response.addCookie(c); } } } } %> 查看用户信息 cookie-user-info.jsp Cookie Login 登录 0) { for (Cookie c:cookies) { if (c.getName().equals(\"username\")) { username = URLDecoder.decode(c.getValue(), \"utf-8\"); } if (c.getName().equals(\"password\")) { password = URLDecoder.decode(c.getValue(), \"utf-8\"); } } } %> 用户名： 密 码： Session与Cookie的对比 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/java-web/commands-and-actions.html":{"url":"pages/java-web/commands-and-actions.html","title":"指令与动作include/forward","keywords":"","body":"指令与动作 include指令、include动作，及二者的区别 jsp:forward动作 jsp:param动作 jsp:plugin动作 include指令 include动作 # flush 被包含的页面是否从缓冲区读取 include指令 include动作 语法格式 (见上面) (见上面) 发生作用的时间 页面转换期间 请求期间 包含的内容 文件的实际内容 页面的输出 转换成的Servlet 主页面和包含页面转换为一个Servlet 主页面和包含页面转换为独立的Servlet 编译时间 较慢，资源必须被解析 较快 执行时间 稍快 较慢，每次资源必须被解析 总结：页面内容经常变化时，更适合使用\\动作；不经常变化时，更适合使用include指令；\\动作包含的是执行结果，而include指令包含的是文件内容。 jsp:forward动作 语法： 等同于： request.getRequestDispatcher(\"/url\").forward(request, response); jsp:param动作 语法： 常与 一起使用，作为其的子标签。 jsp:plugin动作 略 商品浏览记录实例 /jsp-commands-and-actions/WebContent/index.jsp 案例：商品浏览记录的实现 采用Model1(JSP + JavaBean)实现 实现DBHelper类 创建实体类 创建业务逻辑类(DAO)，即JavaBeans 创建页面层 商品列表： list = jspCookieItemDao.getAllItems(); if (list.size() == 0) { out.print(\"数据为空！\"); } %> \" target=\"_blank\"> \" height=\"80\"> 价格： 产地： 库存： /jsp-commands-and-actions/WebContent/detail.jsp 案例：商品浏览记录的实现 = len) { return arr; } int end = Math.min(sliceLength + index, len); String[] list = new String[Math.min(sliceLength, len - index)]; for (int i = index, j = 0; i 价格： | 产地： | 库存： \" style=\"max-width:400px\"> \"); } } } // records += request.getParameter(\"id\") + \",\"; // String id = request.getParameter(\"id\"); // 转换为数组 String[] arr = records.split(\"#\"); int len = arr[0] != null && arr[0] != \"\" ? arr.length : 0; // 判断记录是否已存在 if (id != null && !Arrays.asList(arr).contains(id)) { //判断记录条数 String[] tmp = push(slice(arr, len - 4, 5), id); // 保存Cookie // 注意(使用逗号','作为字符串分隔符，jdk1.8中cookie会抛出以下异常：) // java.lang.IllegalArgumentException: An invalid character [44] was present in the Cookie value Cookie cookie = new Cookie(\"recordsCookie\", toString(tmp, \"#\")); // 最大有效时间 cookie.setMaxAge(24 * 3600 * 30); // cookie.setPath(\"/\"); response.addCookie(cookie); } %> 最近浏览商品列表： list = jspCookieItemDao.getViewList(records); if (list.size() == 0) { out.print(\"无浏览记录！\"); } else { %> \" target=\"_blank\"> \" height=\"80\"> 价格： 产地： 库存： /jsp-commands-and-actions/src/com/jspcommands/util/DBHelper.java package com.jspcommands.util; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; public class DBHelper { // 数据库驱动 // private static final String MYSQL_DRIVER = \"com.mysql.jdbc.Driver\"; private static final String ORACLE_DRIVER = \"oracle.jdbc.driver.OracleDriver\"; //驱动 // 连接数据库的URL地址 // private static final String DB_URL = \"jdbc:mysql://localhost:3306/shopping?useUnicode=true&charaterEncoding=UTF-8\"; private static final String DB_URL = \"jdbc:oracle:thin:@//127.0.0.1:1521/orcl\"; // 数据库用户名 private static final String USER_NAME = \"system\"; // 数据库密码 private static final String PASSWORD = \"admin\"; // private static Connection conn = null; // 静态代码块负责加载驱动 static { try { Class.forName(ORACLE_DRIVER); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } } // 单列模式返回数据库连接对象 public static Connection getConnection() { if (conn == null) { try { conn = DriverManager.getConnection(DB_URL, USER_NAME, PASSWORD); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } return conn; } public static void main(String[] args) { try { Connection conn = DBHelper.getConnection(); if (conn != null) { System.out.println(\"数据库连接成功!\"); } else { System.out.println(\"数据库连接失败!\"); } } catch(Exception e) { System.out.println(\"数据库连接失败，发生异常：\"); e.printStackTrace(); } } } /jsp-commands-and-actions/src/com/jspcommands/dao/JspCookieItemDAO.java package com.jspcommands.dao; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.ArrayList; import com.jspcommands.entity.JspCookieItem; import com.jspcommands.util.DBHelper; // 商品业务逻辑类 public class JspCookieItemDAO { // 获取所有商品列表 public ArrayList getAllItems() { Connection conn = null; PreparedStatement stat = null; ResultSet rs = null; ArrayList list = new ArrayList(); // System.out.println(\"=============ArrayList下面尝试获取数据\"); try { conn = DBHelper.getConnection(); String sql = \"select * from jsp_cookie_items\"; stat = conn.prepareStatement(sql); rs = stat.executeQuery(); // System.out.println(\"=============执行try\"); while(rs.next()) { JspCookieItem item = new JspCookieItem(); item.setId(rs.getInt(\"id\")); item.setName(rs.getString(\"name\")); item.setCity(rs.getString(\"city\")); item.setPrice(rs.getDouble(\"price\")); item.setStock(rs.getInt(\"stock\")); item.setCover(rs.getString(\"cover\")); System.out.println(\"=========while循环中: \" + rs.getString(\"name\")); list.add(item); } return list; } catch(Exception ex) { ex.printStackTrace(); } finally { // 释放数据集对象 if (rs != null) { try { rs.close(); rs = null; } catch(Exception ex) { ex.printStackTrace(); } } // 释放语句对象 if (stat != null) { try { stat.close(); stat = null; } catch(Exception ex) { ex.printStackTrace(); } } } return null; } /** * 获取商品详情 * @param id * @return */ public JspCookieItem getDetailById(int id) { Connection conn = null; PreparedStatement stat = null; ResultSet rs = null; try { conn = DBHelper.getConnection(); String sql = \"select * from jsp_cookie_items where id=?\"; stat = conn.prepareStatement(sql); stat.setInt(1, id); rs = stat.executeQuery(); // System.out.println(\"=============执行try\"); if(rs.next()) { JspCookieItem item = new JspCookieItem(); item.setId(rs.getInt(\"id\")); item.setName(rs.getString(\"name\")); item.setCity(rs.getString(\"city\")); item.setPrice(rs.getDouble(\"price\")); item.setStock(rs.getInt(\"stock\")); item.setCover(rs.getString(\"cover\")); return item; } } catch(Exception ex) { ex.printStackTrace(); } finally { // 释放数据集对象 if (rs != null) { try { rs.close(); rs = null; } catch(Exception ex) { ex.printStackTrace(); } } // 释放语句对象 if (stat != null) { try { stat.close(); stat = null; } catch(Exception ex) { ex.printStackTrace(); } } } return null; } /** * get 获取最近浏览的5条记录 * @param records * @return */ public ArrayList getViewList(String records) { ArrayList list = new ArrayList(); if (records != null && records.length() > 0) { String[] arr = records.split(\"#\"); int id; for (int i = arr.length - 1; i >= 0; i--) { id = arr[i] != \"\" ? Integer.parseInt(arr[i]) : 0; if (id > 0) list.add(getDetailById(id)); } } return list; } } /jsp-commands-and-actions/src/com/jspcommands/entity/JspCookieItem.java package com.jspcommands.entity; // 商品实体类 public class JspCookieItem { private int id; private String name; private String city; private Double price; private int stock; private String cover; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } public Double getPrice() { return price; } public void setPrice(Double price) { this.price = price; } public int getStock() { return stock; } public void setStock(int stock) { this.stock = stock; } public String getCover() { return cover; } public void setCover(String cover) { this.cover = cover; } } 源码位置： codes/jsp-commands-and-actions © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/oracle/":{"url":"pages/oracle/","title":"介绍与安装","keywords":"","body":"Oracle 甲骨文公司，全称甲骨文股份有限公司(甲骨文软件系统有限公司)，是全球最大的企业级软件公司，总部位于美国加利福尼亚州的红木滩。1989年正式进入中国市场。2013年，甲骨文已超越 IBM ，成为继 Microsoft 后全球第二大软件公司。 安装与卸载 安装 https://www.oracle.com/downloads/ 卸载 # windows系统运行 deinstall/deinstall.bat 出处或参考资料 https://www.imooc.com/ © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/oracle/users.html":{"url":"pages/oracle/users.html","title":"用户","keywords":"","body":"用户 [!TIP|style:flat|label:系统用户] sys, system。密码为安装软件时设置的密码 sysman。密码为安装软件时设置的密码 scott。密码默认为tiger 权限依次从高到低 使用system用户登录 # 打开SQL Plus工具 [username/password] [@server] [as sysdba|sysoper] # system/pw @orcl as sysdba # orcl 就是自己设置的服务名 不区分大小写 查看登录用户 show user # 结果 USER 为 \"SYS\" 数据字典 desc dba_users 查看有哪些用户，注意SQL语句要以 ; 分号结束。 select username from dba_users; 启用scott用户 默认情况下，该用户为锁定状态。 # 启用用户的语句 alter user username account unlock # alter user scott account lock ORA-01918: 用户 'SCOTT' 不存在 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/oracle/tablespaces.html":{"url":"pages/oracle/tablespaces.html","title":"表空间","keywords":"","body":"表空间 [!TIP|style:flat|label:表空间] 数据库与表空间 表空间实际上是数据库的逻辑存储空间，可以理解为在数据库中开辟的一个空间，用来存储数据库对象。一个数据库可以由多个表空间构成。 此特点也是与MySQL等数据库的主要区别。Oracle的很多优化也是通过表空间来实现的。 表空间与数据文件 表空间实际上是由多个数据文件构成的，数据文件的大小和位置可以由用户自己定义。 表空间可分为：永久表空间、临时表空间、UNDO表空间 永久表空间 数据库中需要永久化存储的一些对象。比如表、视图、存储过程等 临时表空间 数据库操作过程中，中间执行的过程，执行结束后，存放的内容将被自动释放掉。不进行永久性的保存。 UNDO表空间 用于保存事务所修改的旧址，即保存修改之前的数据。可以利用此功能实现回滚等操作。 查看用户的表空间 # 系统用户登录查看的数据字典 dba_tablespaces # 普通用户登录查看的数据字典 user_tablespaces 系统用户 SYSTEM: 系统表空间 SYSAUX: 辅助表空间，安装Oracle示例使用的表空间。 UNDOTBS1: 社交类型表空间 TEMP: USERS: 普通用户 # 系统用户登录查看的数据字典 dba_users # 普通用户登录查看的数据字典 user_users 设置用户的默认或临时表空间 ALTER USER username DEFAULT|TEMPORARY TABLESPACE tablespace_name # alter user system default tablespace xxx [!TIP|style:flat|label:单选] 在Oracle数据库安装完成后，system用户的默认表空间和临时表空间分别是：system, temp 创建表空间 CREATE [TEMPORARY] TABLESPACE tablespace_name TEMPFILE|DATAFILE `xx.dbf` SIZE xx xx.dbf如未指定路径，将被直接存储在Oracle的安装默认目录中。 # 创建一个大小为10M的永久表空间 create tablespace test1_tablespace datafile `test1file.dbf` size 10m; # 创建一个大小为10M的临时表空间 create temporary tablespace temp_test_tablespace tempfile `tempfile1.dbf` size 10m; 查看表空间路径等操作 修改表空间 [!TIP|style:flat|label:修改表空间的状态] 脱机状态 读写状态 设置联机或脱机状态 # 修改表空间的在线状态 ALTER TABLESPACE tablespace_name ONLINE|OFFLINE; 脱机状态的表空间无法使用。 查看online_status # 修改表空间的读写状态 ALTER TABLESPACE tablespace_name READ ONLY|READ WRITE [!TIP|style:flat|label:修改数据文件] 增加数据文件 删除数据文件 # 向tablespace_name中添加一个文件 ALTER TABLESPACE tablespace_name ADD DATAFILE 'xx.dbf' SIZE xx; # 删除数据文件 ALTER TABLESPACE tablespace_name DROP DATAFILE 'filename.dbf' [!WARNING|style:flate|label:注意] 不能删除表空间的第一个数据文件 如果需要删除第一个数据文件，则需将整个表空间删除。 删除表空间 DROP TABLESPACE tablespace_name [INCLUDING CONTENTS] # 只删除表空间，不删除数据文件 drop tablespace test1_tablespace # 删除表空间和文件 drop tablespace test1_tablespace including contents © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/oracle/management-table.html":{"url":"pages/oracle/management-table.html","title":"管理表，数据增删改","keywords":"","body":"管理表 [!TIP|style:flat|label:认识表] 表是存储数据的基本存储单位 表是二维结构，由行(记录)和列(域和字段)组成 约定 1、每一列数据必须具有相同数据类型。 2、列名是唯一的 3、每一行数据的唯一性 数据类型 字符型、数值型、日期型、其他类型。 字符型 n最大值 说明 CHAR(n) 2000 n为10时，输入长度3字符的字符将补齐7个空格，易造成空间浪费 NCHAR(n) 1000 按Unicode格式存放数据，常用于存储汉字 VARCHAR2(n) 4000 存储可变长度数据类型，相对CHAR更节约空间 NVARCHAR2(n) 2000 支持Unicode格式存放 数值型 说明 NUMBER(p,s) p有效数字；s小数点后位数，支持正负数 FLOAT(n) 用于存储二进制数据，能表示二进制位数1-126位。转换成10进制，则需乘以0.30103 NUMBER(5, 2) # 有效数字5位，保留2位小数，如123.45 日期型 说明 DATE 范围：公元前4712年1月1日，至公元9999年12月31日，精确到秒 TIMESTAMP 其他类型 最大能存储 说明 BLOB 4GB数据 以二进制格式存储 CLOB 4GB数据 以字符串形式存储 表的相关操作 创建表、修改表、删除表 创建表语法 CREATE TABLE table_name ( column_name datatype [default value], ... ) # default 添加默认值，默认value获取系统当前时间sysdate 实例： [!TIP|style:flat|label:修改表] 添加字段、更改字段数据类型、修改字段名、删除字段、修改表名 添加字段 ALTER TABLE table_name ADD column_name datatype [default value]; # alter table user_info add remark varchar2(500); 更改字段数据类型 ALTER TABLE table_name MODIFY column_name datatype [default value]; # alter table user_info modify remark varchar2(300); # alter table user_info modify password number(10, 0); 删除字段 ALTER TABLE table_name DROP COLUMN column_name; # alter table user_info drop column remark; 修改字段名称 ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name; # alter table user_info rename column user_name to username; 修改表名 RENAME table_name TO new_table_name; # rename user_info to userinfo; [!TIP|style:flat|label:删除表] 删除表中所有数据 删除表 删除表中所有数据 TRUNCATE TABLE table_name 删除表 DROP TABLE table_name 操作表中数据 添加数据：INSERT语句、操作实例、复制表数据 INSERT语句 # INSERT语句 INSERT INTO table_name (column1, column2, ...) VALUES(value1, value2, ...) # column1 ...栏可以省略，但value栏的顺序必须与数据库表字段顺序一致 实例 向表中所有字段添加值 insert into user_info values(1, 'jock', '123456', '1522@qq.com', sysdate); # sysdate 获取系统当前时间 向表中指定字段添加值 insert into user_info (id, user_name, password) values(2, 'tom', '123456'); 复制表数据 # 在创建时复制 CREATE TABLE table_new AS SELECT column1, ...|* FROM table_old # column 指定需要复制的字段 # * 代表复制所有字段数据 # create table new_userinfo as select * from user_info; # create table new_userinfo2 as select id, user_name from user_info; 在添加时复制 INSERT INTO table_new [(column1, ...)] SELECT column1, ...|* FROM table_old # 插入表的字段顺序及数据类型，需要与table_old表一致。 # insert into new_userinfo select * from user_info; # insert into new_userinfo (id, user_name) select id, user_name from user_info; 修改数据 # UPDATE语句 UPDATE table_name SET column1=value1, ... [WHERE conditions] # 无条件更新 update user_info set password='1111111'; # 有条件更新 update user_info set password='222222', email='8888@xx.com' where id='2'; 删除数据 # DELETE语句 DELETE FROM table_name [WHERE conditions] # drop删除表数据，要比delete快。 # 无条件删除 delete from user_info_copy; # 有条件删除 delete from user_info where id='1'; © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/oracle/constraint.html":{"url":"pages/oracle/constraint.html","title":"约束constraint","keywords":"","body":"约束 constraint [!TIP|style:flat|label:约束的作用] 定义规则：哪些字段是必须的，哪些字段该输入什么类型的值 确保完整性：数据的精确性、可靠性。 非空约束、主键约束、外键约束、唯一约束、检查约束 非空约束 [!TIP|style:flat|label:非空约束] 在创建表时，设置非空约束 NOT NULL 在修改表时，添加非空约束 在修改表时，去除非空约束 在创建表时，设置非空约束 CREATE TABLE table_name ( column_nae datatype NOT NULL, ... ) 实例： create table user_info2 ( id number(10, 0), username varchar2(32) not null, password varchar2(64) not null ); 在修改表时，添加非空约束 ALTER TABLE table_name MODIFY column_name datatype NOT NULL; # 如果被修改的字段，在表中已有空值将会抛出异常 在修改表时，去除非空约束 ALTER TABLE table_name MODIFY column_name datatype NULL; # alter table user_info modify user_name varchar2(64) null; 主键约束 [!TIP|style:flat|label:主键约束] 作用：确保表当中每一行数据的唯一性 一张表只能设置一个主键约束 主键约束可以由多个字段构成（联合主键或复合主键） 在创建表时设置主键约束、在修改表时添加主键约束、更改约束的名称、删除主键约束 在创建表时设置主键约束 CREATE TABLE table_name ( column_name datatype PRIMARY KEY, ... ) 实例 create table user_info3 ( id number(10, 0) primary key, username varchar2(32), password varchar2(64) ); 联合主键或复合主键 CONSTRAINT constraint_name PRIMARY KEY(column_name1, ...) create table user_info4 ( id number(10, 0), username varchar2(64), password varchar(64), constraint pk_id_username primary key (id, username) ); # pk_id_username 可任意，取合法名称都行 创建完成后，忘记了主键的名称，则可以通过 user_constraints 在修改表时添加主键约束 ALTER TABLE table_name ADD CONSTRAINT constraint_name PRIMARY KEY (column_name1, ...); # 更改约束的名称constraint_name ALTER TABLE table_name RENAME CONSTRAINT old_name TO new_name [!TIP|style:flat|label:删除主键约束] 禁用与启用 直接删除 # 暂时禁用，后期可能还会启用的情况 DISABLE|ENABLE CONSTRAINT constraint_name # 禁用new_pk_id # alter table user_info disable constraint new_pk_id; # 查看禁用状态 # select constraint_name, status from user_constraints where table_name='USER_INFO'; # 直接删除1 DROP CONSTRAINT constraint_name # alter table user_info drop constraint new_pk_id; # 查看删除后的状态 # select constraint_name, status from user_constraints where table_name='USER_INFO'; # 结果：未选定行 # 直接删除2 DROP PRIMARY KEY [CASCADE] # CASCADE 其他表引用该字段的地方，也一起删掉约束 # alter table user_info3 drop primary key; 外键约束 [!TIP|style:flat|label:外键约束] 唯一一个涉及两个表当中字段关系约束。 又称主从表关系 在创建表时设置外键约束、在修改表时添加外键约束、删除外键约束 在创建表时设置外键约束1 CREATE TABLE table1 ( column_name datatype REFERENCES table2 (column_name), ... ); # table2 为主表 # table1 为从表 [!WARNING|style:flat|label:注意] 设置外键约束时，主表的字段必须是主键。 主从表中相应字段必须是同一个数据类型。 从表中外键字段的值，必须来自主表中的相应字段的值，或者为null值。 在创建表时设置外键约束2 CONSTRAINT constraint_name FOREIGN KEY (column_name) REFERENCES main_table_name (column_name) [ON DELETE CASCADE] # constraint_name通常以fk开头(FOREIGN KEY首字母)，且不能重名。 # ON DELETE CASCADE级联删除，即主表中某条数据被删除，在从表中使用了该数据的行也将被删除。从而确保主从表的完整性。 在修改表时添加外键约束 ADD CONSTRAINT constraint_name FOREIGN KEY (column_name) REFERENCES table_name (column_name) [ON DELETE CASCADE] [!TIP|style:flat|label:删除外键约束] 禁用与启用 直接删除 禁用与启用 DISABLE|ENABLE CONSTRAINT constraint_name 直接删除 DROP CONSTRAINT constraint_name; 唯一约束 [!TIP|style:flat|label:唯一约束 UNIQUE] 作用：保证字段值的唯一性。 与主键约束的区别 主键约束 唯一约束 主键字段值必须是非空的 允许有一个空值 主键在每张表中只有一个 在每张表中可以有多个 在创建表时设置唯一约束、在修改表时添加唯一约束、删除唯一约束 # 在创建表时设置唯一约束，分列级和表级 # 列级 CREATE TABLE table_name (column_name datatype UNIQUE, ...) # 表级 CONSTRAINT constraint_name UNIQUE (column_name) # constraint_name 约束名必须是唯一的。 在修改表时添加唯一约束 ADD CONSTRAINT constraint_name UNIQUE (column_name); 删除唯一约束 # 禁用/启用 ALTER TABLE table_name DISABLE|ENABLE CONSTRAINT constraint_name # 删除唯一约束 ALTER TABLE table_name DROP CONSTRAINT constraint_name 检查约束 作用：使表中的值更具有实际意义。 一张表中可以有多个检查约束。 例子，员工信息： 年龄：1000 工资：-50 电话号码：080-2222-3333 # 年龄、工资不符合（没有）实际意义。 在创建表时设置检查约束、在修改表时添加检查约束、删除检查约束 # 在创建表时设置检查约束：列级 CREATE TABLE table_name (column_name datatype CHECK(expressions), ...) # 在创建表时设置检查约束：表级 CONSTRAINT constraint_name CHECK(expressions) # 在修改表时添加检查约束 ALTER TABLE table_name ADD CONSTRAINT constraint_name CHECK (expressions); # 禁用、启用 ALTER TABLE table_name DISABLE|ENABLE CONSTRAINT constraint_name # 删除检查约束 ALTER TABLE table_name DROP CONSTRAINT constraint_name 总结 非空约束 主键约束：每张表只能有一个，可以由多个字段构成。 外键约束： 涉及两个表之间的关系 唯一约束 检查约束 [!TIP|style:flat|label:具体操作] 在创建表时设置约束： 非空约束只能在列级设置，不能再表级设置； 其他约束既可以在列级设置，也可以在表级设置； 并且设置非空约束是没有名字的。 在修改表时添加约束： 与其他不同的还是 非空约束，使用的是修改字段方法 ALTER TABLE table_name MODIFY column_name datatype NOT NULL; 更改约束的名称： 非空约束没有名称，所有不能改名； 其他约束可以修改约束名称； 通过数据字典 user_constraints查看约束名称、类型等信息； ALTER TABLE table_name RENAME CONSTRAINT old_name TO new_name; 删除约束： 非空约束比较特殊，使用的是修改字段方法，即将NOT NULL改为可以为空NULL即可。ALTER TABLE table_name MODIFY column_name datatype NULL; 其他约束启用enable或禁用disable，DISABLE|ENABLE CONSTRAINT constraint_name；彻底删除 DROP CONSTRAINT constraint_name 删除主键约束: DROP PRIMARY KEY © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/oracle/sql.html":{"url":"pages/oracle/sql.html","title":"查询语句sql","keywords":"","body":"查询语句sql 基本查询语句 在SQL*PLUS中设置格式 查询表中的所有字段及指定字段 给字段设置别名：只针对查询结果，并未更改字段名称 运算符和表达式 在SELECT语句中使用运算符 带条件的查询 模糊查询 范围查询 对查询结果排序 case...when语句的使用 decode函数的使用 基本查询语句 # 从一张表table_name中查询内容 SELECT [DISTINCT] column_name1, ...|* FROM table_name [WHERE conditions] DISTINCT 不显示重复的记录。 在SQL*PLUS中设置格式 设置查询结果显示字段名名称： COLUMN column_name HEADING new_name COLUMN 可以简写为 COL 设置查询结果显示格式： COLUMN column_name FORMAT dataformat dataformat 格式 说明 字符类型 a10 10代表字符显示长度 数字类型 99.9 用9表示一个数字，10输出结果为10.0；加其他符号将被直接输出，如$99.9，输出为$10.0 [!WARNING|style:flat|label:注意] 字符类型只能设置其显示长度。 清除已设置的格式： COLUMN column_name CLEAR # col username clear 查询表中的所有字段及指定字段 # 查询表中的所有字段 select * from table_name; 给字段设置别名：只针对查询结果，并未更改字段名称 SELECT column_name AS new_name, ... FROM table_name [!WARNING|style:flat|label:注意] AS关键字可以省略，用空格隔开原来的字段名和新字段名即可。 运算符和表达式 表达式 = 操作数 + 运算符 # 表达式：2 * 3 Oracle中的操作数可以有变量、常量和字段 算术运算符：+, -, *, / 比较运算符：>, >=, (不等) 逻辑运算符：and, or, not，优先级按not、and、or顺序依次递减 [!TIP|style:flat|lable:优先级] 逻辑运算符优先级按not、and、or顺序依次递减 比较运算符的优先级高于逻辑运算符 在SELECT语句中使用运算符 带条件的查询 单一条件查询 select * from users where id='2'; 多条件查询 select * from users where username='Jack' or salary>1000; 模糊查询 通配符的使用 _ 一个 _ 只能代表一个字符 % 可以代表0到多个任意字符 使用LIKE查询 # 查询用户名以t开头的用户信息 select * from users where username like 't%'; 范围查询 # 查询工资范围 # salary >= 600 and salary 对查询结果排序 SELECT ... FROM ... [WHERE] ORDER BY column1 DESC/ASC, ... SELECT ... FROM ... [WHERE] ORDER BY column1 DESC/ASC, column2 DESC/ASC... # 关键字 order by # desc 升序 # asc 降序 case...when语句的使用 CASE column_name WHEN value1 THEN result1, ... [ELSE result] END CASE WHEN column_name=value1 THEN result1, ...[ELSE result] END decode函数的使用 decode (column_name, value1, result1, ..., defaultvalue) © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/oracle/3-Oracle高级查询.html":{"url":"pages/oracle/3-Oracle高级查询.html","title":"Oracle高级查询","keywords":"","body":"Oracle高级查询 前面课程：《Oracle数据库开发必备利器之SQL基础》，《Oracle数据库开发利器之函数》 课程摘要 分组查询 多表查询 子查询 综合实例 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/oracle/pl-sql.html":{"url":"pages/oracle/pl-sql.html","title":"PL/SQL程序设计","keywords":"","body":"PL/SQL程序设计 Oracle数据库开发必备利器之PL SQL SQL Developer 19.2 Downloads https://www.oracle.com/tools/downloads/sqldev-v182-downloads.html https://www.oracle.com/tools/downloads/sqldev-v192-downloads.html https://docs.oracle.com/en/database/oracle/sql-developer/index.html 连接数据库： 设置SQL编辑器行编号，和添加MySQL等第三方连接驱动： 连接MySQL数据库 参考资料 https://www.imooc.com/learn/360 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/file/":{"url":"pages/file/","title":"Java I/O文件处理","keywords":"","body":"文件处理 文件编码 File类的使用 RandomAccessFile的使用 字节流的使用 字符流的使用 对象的序列化与反序列化 文件编码 String s = \"您好世界ABC\"; /** * 字符串转byte[] */ // 转换成字节码序列用的是项目默认的编码GBK，中文占两个字节 byte[] bytes1 = s.getBytes(); for (byte b : bytes1) { // 把字节（转换错了int）以16进制的方式显示 System.out.print(Integer.toHexString(b & 0xff) + \" \"); } // 结果：c4 fa ba c3 ca c0 bd e7 41 42 43 System.out.println(\"\"); byte[] bytes2 = s.getBytes(\"GBK\"); for (byte b : bytes2) { System.out.print(Integer.toHexString(b & 0xff) + \" \"); } // 结果：c4 fa ba c3 ca c0 bd e7 41 42 43 // GBK编码中文占2个字节，英文占1个字节 System.out.println(\"\"); // utf-8 byte[] bytes3 = s.getBytes(\"utf-8\"); for (byte b : bytes3) { System.out.print(Integer.toHexString(b & 0xff) + \" \"); } // 结果：e6 82 a8 e5 a5 bd e4 b8 96 e7 95 8c 41 42 43 // utf-8编码中文占3个字节，英文占1个字节 System.out.println(\"\"); // Java是双字节编码utf-16be byte[] bytes4 = s.getBytes(\"utf-16be\"); for (byte b : bytes4) { System.out.print(Integer.toHexString(b & 0xff) + \" \"); } // 结果：60 a8 59 7d 4e 16 75 4c 0 41 0 42 0 43 // utf-16be中文占2个字节，英文占用2个字节 System.out.println(\"\"); /** * byte[]转字符串 * 当字节序列为某种编码时，这个时候想把字节序列变成字符串， * 也需要用这种编码方式，否则会出现乱码 */ // 用项目默认的编码 String str1 = new String(bytes1); System.out.println(str1); String str2 = new String(bytes2, \"GBK\"); System.out.println(str2); String str3 = new String(bytes3, \"utf-8\"); System.out.println(str3); String str4 = new String(bytes4, \"utf-16be\"); System.out.println(str4); /** * 文本文件 就是字节序列， * 其可以使任意编码的字节序列 * *在中文机器上直接创建文本文件，该文件只认识ansi编码 */ File类常用API java.io.File类用于表示文件（或目录） File类只用于表示文件（或目录）的信息（名称、大小等），不能用于文件内容的访问。 File file = new File(\"D:\\\\java\\\\test\"); System.out.println(\"文件是否存在：\" + (file.exists() ? \"是\" : \"否\")); // 不存在文件（目录）创建 if (!file.exists()) { file.mkdir(); // 多级目录创建 //file.mkdirs(); } else { file.delete(); } // 是目录或目录存在返回true，否则返回false System.out.println(\"是否为目录：\" + file.isDirectory()); System.out.println(\"是否为文件：\" + file.isFile()); System.out.println(); //File file2 = new File(\"D:\\\\java\\\\test.txt\"); File file2 = new File(\"D:\\\\java\", \"test.txt\"); if (!file2.exists()) { try { file2.createNewFile(); } catch (IOException e) { e.printStackTrace(); } } else { file2.delete(); } System.out.println(file);//D:\\java\\test System.out.println(file.getAbsolutePath());//D:\\java\\test System.out.println(file.getParent());//D:\\java System.out.println(file.getName());//test System.out.println(); System.out.println(file2.getParent());//D:\\java System.out.println(file2.getName());//test.txt list() 与 listFiles() /** * 列出指定目录下的所有文件及子文件夹（包含其子目录） * @param dir * @param deep */ public static void printListDirectory(File dir, boolean deep) throws IOException { if (!dir.exists()) { throw new IllegalArgumentException(\"目录不存在，\" + dir); } if (!dir.isDirectory()) { throw new IllegalArgumentException(dir + \", 不是目录\"); } //返回目录下的所有文件或子目录，及子目录的所有文件及目录 if (deep) { File[] files = dir.listFiles(); if (files != null && files.length > 0) { for (File f : files) { if (f.isDirectory()) { printListDirectory(f, true); } else { System.out.println(f); } } } } //返回目录下的文件或子目录名称，不包含子目录下的内容 else { String[] fileNames = dir.list(); for (String str : fileNames) { System.out.println(dir + \"\\\\\" + str); } } } RandomAccessFile java提供的对文件内容的访问，既可以读文件，也可以写文件。 支持随机访问文件，可以访问文件的任意位置。 (1)java文件模型：在硬盘上的文件是byte byte byte存储的，是数据的集合 (2)打开文件：有两种模式rw（读写），r（只读）。 RandomAccessFile raf = new RandomAccessFile(file, \"rw\"); 文件指针，打开文件时指针在开头 pointer = 0; (3)写方法 raf.write(int); 只写一个字节（后8位），同时指针指向下一个位置，准备再次写入。 (4)读方法 raf.read(); 从指针位置读一个字节。 (5)文件读写完成以后，一定要关闭，否则可能会抛出意想不到的异常（Oracle官方说明） File demo = new File(\"D:\\\\java\\\\demo\"); if (!demo.exists()) { demo.mkdir(); } File file = new File(demo, \"raf.dat\"); if (!file.exists()) { file.createNewFile(); } RandomAccessFile raf = new RandomAccessFile(file, \"rw\"); // 指针的位置 System.out.println(raf.getFilePointer()); // write方法每次只能写一个字节 raf.write('A'); System.out.println(raf.getFilePointer()); raf.write('B'); int num = 0x7fffffff; // write方法每次只能写一个字节，如果把num写进去就的写4次 raf.write(num >>> 24); raf.write(num >>> 16); raf.write(num >>> 8); raf.write(num); //可以直接写入一个int raf.writeInt(num); String s = \"中\"; byte[] gbk = s.getBytes(\"GBK\"); raf.write(gbk); System.out.println(raf.length()); // 读文件，把指针移到头部 raf.seek(0); //一次性读取，把文件中的内容，读取到字节数组中 byte[] buf = new byte[(int)raf.length()]; raf.read(buf); System.out.println(Arrays.toString(buf)); for (byte b : buf) { System.out.print(Integer.toHexString(b & 0xff) + \" \"); } raf.close(); 字节流 FileInputStream IO流（输入流、输出流） 字节流、字符流 [!TIP|style:flat|label: 1.字节流] InputStream、OutputStream InputStream抽象了应用程序读取数据的方式 OutputStream抽象了应用程序写出数据的方式 EOF = End 读到-1，即读到结尾 输入流基本方法： // 读取一个字节无符号填充到int低8位，-1是EOF int b = in.read(); // 读取数据到字节数组buf in.read(byte[] buf); // 读取数据到字节数组buf，从buf的start位置开始，存放size长度的数据 in.read(byte[] buf, int start, int size); 输出流基本方法： // 写出一个byte到流，b的低8位（一个整型32位） out.write(int b); // 将buf字节数组都写入到流 out.write(buf); // 字节数组buf从start位置开始写size长度的字节到流 out.write(byte[] buf, int start, int size); [!TIP|style:flat|label: FileInputStream] FileInputStream(InputStream的子类，及继承了InputStream)，具体实现了在文件上读取数据 /** * 读取指定文件内容，按照16进制输出到控制台 * 并且每输出10个byte换行 * @param fileName * @throws IOException */ public static void printHex(String fileName) throws IOException { // 把文件作为字节流进行读取操作 FileInputStream in = new FileInputStream(fileName); int b; int count = 1; while((b = in.read()) != -1) { // 单位数前补0，及小于10的数 if (b /** * printHexByByteArray * @param fileName * @throws IOException */ public static void printHexByByteArray(String fileName) throws IOException { File file = new File(fileName); FileInputStream in = new FileInputStream(file); byte[] buf = new byte[(int)file.length()]; // 从in中排量读取字节，放入到buf这个字节数组中 // 从第0个位置开始放，最多放buf.length个 // 返回的是读到的字节的个数 int bytes = in.read(buf, 0, buf.length); int count = 1; for (int i = 0; i = 0x0 && b Test String filePath = \"D:\\\\java\\\\test.txt\"; IOUtils.printHex(filePath); System.out.println(\"\\n\"); IOUtils.printHexByByteArray(filePath); System.out.println(\"\\n\"); IOUtils.printHexByByteArray2(filePath); [!TIP|style:flat|label: FileOutputStream] FileOutputStream(OutputStream的子类，及继承了OutputStream)，实现了向文件中写入byte数据的方法 String filePath = \"D:\\\\java\\\\temp\\\\out.dat\"; // 如果文件不存在，则直接创建；如果存在，删除后再创建 // #若有第二个参数：true往文件里追加内容 FileOutputStream out = new FileOutputStream(filePath); // 写出了A的低8位 out.write('A'); // 写出了B的低8位 out.write('B'); // write只能写8位，即写一个int需要写4次 int a = 10; out.write(a >>> 24); out.write(a >>> 16); out.write(a >>> 8); out.write(a); byte[] gbk = \"中国\".getBytes(\"GBK\"); out.write(gbk); out.close(); IOUtils.printHex(filePath); IOUtils.java /** * file copy * @param srcFile * @param destFile * @throws IOException */ public static void fileCopy(File srcFile, File destFile) throws IOException { if (!srcFile.exists()) { throw new IllegalArgumentException(\"文件不存在。\" + srcFile); } if (!srcFile.isFile()) { throw new IllegalArgumentException(\"非文件对象。\" + srcFile); } FileInputStream in = new FileInputStream(srcFile); FileOutputStream out = new FileOutputStream(destFile); byte[] buffers = new byte[(int)srcFile.length()]; int n; while((n = in.read(buffers, 0, buffers.length)) != -1) { out.write(buffers, 0, n); out.flush(); } in.close(); out.close(); } FileOutPutDemo.java File srcFile = new File(\"D:\\\\java\\\\temp\\\\out.dat\"); File destFile = new File(\"D:\\\\java\\\\temp\\\\copy.txt\"); IOUtils.fileCopy(srcFile, destFile); DataInputStream/DataOutputStream 对“流”功能的扩展，可以更加方便的读取int、long、字符等数据类型的数据。 # DataOutputStream writeInt()/writeDouble()/writeUTF()... DataOutputStreamDemo.java package file.io; import java.io.DataOutputStream; import java.io.FileOutputStream; import java.io.IOException; public class DataOutputStreamDemo { public static void main(String[] args) throws IOException { String filePath = \"D:\\\\java\\\\temp\\\\dos.dat\"; FileOutputStream fos = new FileOutputStream(filePath); DataOutputStream dos = new DataOutputStream(fos); // write dos.writeInt(10); dos.writeInt(-10); dos.writeLong(10l); dos.writeDouble(10.5); // 采用utf-8编码输出 dos.writeUTF(\"中国\"); // 采用utf-16be编码输出 dos.writeChars(\"中国\"); dos.close(); IOUtils.printHex(filePath); System.out.println(\"\\n\"); IOUtils.printHexByByteArray(filePath); System.out.println(\"\\n\"); IOUtils.printHexByByteArray2(filePath); } } DataInputStreamDemo.java package file.io; import java.io.DataInputStream; import java.io.FileInputStream; import java.io.IOException; public class DataInputStreamDemo { public static void main(String[] args) throws IOException { String filePath = \"D:\\\\java\\\\temp\\\\dos.dat\"; IOUtils.printHex(filePath); System.out.println(\"\\n\"); FileInputStream inputFile = new FileInputStream(filePath); DataInputStream dis = new DataInputStream(inputFile); // read int i = dis.readInt(); System.out.println(i); i = dis.readInt(); System.out.println(i); long l = dis.readLong(); System.out.println(l); double d = dis.readDouble(); System.out.println(d); String s = dis.readUTF(); System.out.println(s); dis.close(); } } © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-02-29 11:04:38 "},"pages/message-digest/":{"url":"pages/message-digest/","title":"MD2/MD4/MD5","keywords":"","body":"消息摘要算法 MD(Message Digest) SHA(Secure Hash Algorithm) MAC(Message Authentication Code) 其他如：RipeMD, Tiger, Whirlpool, GOST3411等，均由Bouncy Castle实现。 消息摘要算法--MD(Message Digest) 作用：验证数据的完整性 是数字签名核心算法 MD5 MD家族（128位摘要信息）-MD2，MD4 算法 摘要长度 实现方法 MD2 128 JDK MD4 128 Bouncy Castle MD5 128 JDK 代码实现 package md.test; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.security.Security; import org.apache.commons.codec.binary.Hex; import org.apache.commons.codec.digest.DigestUtils; import org.bouncycastle.crypto.Digest; import org.bouncycastle.crypto.digests.MD2Digest; import org.bouncycastle.crypto.digests.MD4Digest; import org.bouncycastle.crypto.digests.MD5Digest; import org.bouncycastle.jce.provider.BouncyCastleProvider; /** * Message Digest * @author Capricorncd * https://github.com/capricorncd * */ public class TestMessageDigest { private static final String MD2 = \"MD2\"; private static final String MD4 = \"MD4\"; private static final String MD5 = \"MD5\"; public static void main(String[] args) { String src = \"I love the world.\"; jdkMD(src, MD2); jdkMD(src, MD4); jdkMD(src, MD5); bcMD(src, MD2, new MD2Digest()); bcMD(src, MD4, new MD4Digest()); bcMD(src, MD5, new MD5Digest()); bouncyCastleMD(src, MD2); bouncyCastleMD(src, MD4); bouncyCastleMD(src, MD5); ccMD(src, MD2); ccMD(src, MD4); ccMD(src, MD5); } /** * JDK MD * @param src source * @param mdType MD2,MD5 * @return String result */ public static String jdkMD(String src, String mdType) { String result = null; try { MessageDigest md = MessageDigest.getInstance(mdType); byte[] mdBytes = md.digest(src.getBytes()); // toHex result = Hex.encodeHexString(mdBytes); } catch (NoSuchAlgorithmException e) { // e.printStackTrace(); result = e.getMessage(); } println(mdType + \":\", result, \"by JDK\"); return result; } /** * bouncy castle MD * @param src source * @param mdType message digest type * @param digest org.bouncycastle.crypto.Digest * @return String result */ public static String bcMD(String src, String mdType, T digest) { byte[] srcBytes = src.getBytes(); digest.update(srcBytes, 0, srcBytes.length); byte[] resBytes = new byte[digest.getDigestSize()]; digest.doFinal(resBytes, 0); String result = org.bouncycastle.util.encoders.Hex.toHexString(resBytes); println(mdType + \":\", result, \"by Bouncycastle\"); return result; } /** * bouncy castle provider MD * @param src source * @param mdType message digest type * @return String result */ public static String bouncyCastleMD(String src, String mdType) { String result = null; Security.addProvider(new BouncyCastleProvider()); try { MessageDigest md = MessageDigest.getInstance(mdType); byte[] mdBytes = md.digest(src.getBytes()); result = Hex.encodeHexString(mdBytes); } catch (NoSuchAlgorithmException e) { // e.printStackTrace(); result = e.getMessage(); } println(mdType + \":\", result, \"by BouncyCastleProvider\"); return result; } /** * org.apache.commons.codec.digest.DigestUtils * @param src source * @param mdType message digest type * @return String result */ public static String ccMD(String src, String mdType) { String result = null; switch(mdType) { case MD2: result = DigestUtils.md2Hex(src.getBytes()); break; case MD4: result = \"The MD4 method is not implemented.\"; break; case MD5: result = DigestUtils.md5Hex(src.getBytes()); break; } println(mdType + \":\", result, \"by org.apache.commons.codec.digest.DigestUtils\"); return result; } /** * System.out.println * @param args */ public static void println(Object ...args) { for (Object o : args) { System.out.print(o + \" \"); } System.out.print(\"\\n\"); } } 运行结果： MD2: b749ef6943db8fa96fa688a1077224a3 by JDK MD4: MD4 MessageDigest not available by JDK MD5: 2947f614c460347649185e62ee914eac by JDK MD2: b749ef6943db8fa96fa688a1077224a3 by Bouncycastle MD4: 9df4c1b595403939d490ad7c66cf7710 by Bouncycastle MD5: 2947f614c460347649185e62ee914eac by Bouncycastle MD2: b749ef6943db8fa96fa688a1077224a3 by BouncyCastleProvider MD4: 9df4c1b595403939d490ad7c66cf7710 by BouncyCastleProvider MD5: 2947f614c460347649185e62ee914eac by BouncyCastleProvider MD2: b749ef6943db8fa96fa688a1077224a3 by org.apache.commons.codec.digest.DigestUtils MD4: The MD4 method is not implemented. by org.apache.commons.codec.digest.DigestUtils MD5: 2947f614c460347649185e62ee914eac by org.apache.commons.codec.digest.DigestUtils 消息摘要算法--应用 注册、登录密码处理 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-03-22 16:51:20 "},"pages/message-digest/SHA.html":{"url":"pages/message-digest/SHA.html","title":"SHA-1/SHA-2","keywords":"","body":"消息摘要算法--SHA SHA(Secure Hash Algorithm) 安全散列算法的简称。 固定长度摘要信息 SHA-1, SHA-2(SHA-224, SHA-256, SHA-384, SHA-512) 算法 摘要长度 实现方法 SHA-1 160 JDK SHA-224 224 Bouncy Castle/JDK1.8 SHA-256 256 JDK SHA-384 384 JDK SHA-512 512 JDK 代码实现 package md.test; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import org.apache.commons.codec.binary.Hex; import org.apache.commons.codec.digest.DigestUtils; import org.bouncycastle.crypto.Digest; import org.bouncycastle.crypto.digests.SHA1Digest; import org.bouncycastle.crypto.digests.SHA224Digest; import org.bouncycastle.crypto.digests.SHA256Digest; import org.bouncycastle.crypto.digests.SHA384Digest; import org.bouncycastle.crypto.digests.SHA512Digest; /** * Secure Hash Algorithm * @author Capricorncd * https://github.com/capricorncd */ public class TestSHA { private static final String SHA = \"SHA\"; private static final String SHA_224 = \"SHA-224\"; private static final String SHA_256 = \"SHA-256\"; private static final String SHA_384 = \"SHA-384\"; private static final String SHA_512 = \"SHA-512\"; public static void main(String[] args) { String src = \"Test Secure Hash Algorithm.\"; // JDK jdkSHA(src, SHA); jdkSHA(src, SHA_224); jdkSHA(src, SHA_256); jdkSHA(src, SHA_384); jdkSHA(src, SHA_512); // Bouncy Castle println(\"\"); bcSHA(src, SHA, new SHA1Digest()); bcSHA(src, SHA_224, new SHA224Digest()); bcSHA(src, SHA_256, new SHA256Digest()); bcSHA(src, SHA_384, new SHA384Digest()); bcSHA(src, SHA_512, new SHA512Digest()); // org.apache.commons.codec.digest.DigestUtils println(\"\"); ccSHA(src, SHA); ccSHA(src, SHA_224); ccSHA(src, SHA_256); ccSHA(src, SHA_384); ccSHA(src, SHA_512); } /** * JDK SHA * @param src source * @param algorithm algorithm type */ public static void jdkSHA(String src, String algorithm) { String result = null; try { MessageDigest md = MessageDigest.getInstance(algorithm); byte[] mdBytes = md.digest(src.getBytes()); result = Hex.encodeHexString(mdBytes); } catch (NoSuchAlgorithmException e) { // e.printStackTrace(); result = e.getMessage(); } println(algorithm + \":\", result, \"by JDK\"); } /** * Bouncy Castle SHA * @param Digest * @param src source * @param algorithm * @param digest Digest */ public static void bcSHA(String src, String algorithm, T digest) { // input bytes byte[] srcBytes = src.getBytes(); digest.update(srcBytes, 0, srcBytes.length); // result bytes byte[] resBytes = new byte[digest.getDigestSize()]; digest.doFinal(resBytes, 0); // to Hex String result = org.bouncycastle.util.encoders.Hex.toHexString(resBytes); println(algorithm + \":\", result, \"by Bouncy Castle\"); } /** * org.apache.commons.codec.digest.DigestUtils * @param src * @param algorithm */ public static void ccSHA(String src, String algorithm) { String result = null; try { switch(algorithm) { case SHA: result = DigestUtils.sha1Hex(src); break; case SHA_224: result = DigestUtils.sha3_224Hex(src); break; case SHA_256: result = DigestUtils.sha256Hex(src); break; case SHA_384: result = DigestUtils.sha384Hex(src); break; case SHA_512: result = DigestUtils.sha512Hex(src); break; } } catch (Exception e) { result = e.getMessage(); } println(algorithm + \":\", result, \"by org.apache.commons.codec.digest.DigestUtils\"); } /** * System.out.println * @param args */ public static void println(Object ...args) { for (Object o : args) { System.out.print(o + \" \"); } System.out.print(\"\\n\"); } } 运行结果： SHA: 1ec4fe70c8223dbf362dd02481d2abe032aeaa23 by JDK SHA-224: 7ce9d2ecd24444271fd823c8ded2931fa35ae70c747350004bce6291 by JDK SHA-256: fc0de412e726341a95ae30b8ede3dfbb502fa50f9532439e45ca86cdfa725489 by JDK SHA-384: 75cd6f06373ff58d7f50d02a68116108d1c56761e401f20dda6a3fa863b477bb2ce2030d8c760bf9da228d4623262273 by JDK SHA-512: 9e9b3e31616ac90d2ec9981a2ba05c2045af58af9c279aa5d9fc45248982fe4eafaeccc12270310c2819b5b8b7541f5d9ba884bfac1b3c3fdfe8c42adb283643 by JDK SHA: 1ec4fe70c8223dbf362dd02481d2abe032aeaa23 by Bouncy Castle SHA-224: 7ce9d2ecd24444271fd823c8ded2931fa35ae70c747350004bce6291 by Bouncy Castle SHA-256: fc0de412e726341a95ae30b8ede3dfbb502fa50f9532439e45ca86cdfa725489 by Bouncy Castle SHA-384: 75cd6f06373ff58d7f50d02a68116108d1c56761e401f20dda6a3fa863b477bb2ce2030d8c760bf9da228d4623262273 by Bouncy Castle SHA-512: 9e9b3e31616ac90d2ec9981a2ba05c2045af58af9c279aa5d9fc45248982fe4eafaeccc12270310c2819b5b8b7541f5d9ba884bfac1b3c3fdfe8c42adb283643 by Bouncy Castle SHA: 1ec4fe70c8223dbf362dd02481d2abe032aeaa23 by org.apache.commons.codec.digest.DigestUtils SHA-224: java.security.NoSuchAlgorithmException: SHA3-224 MessageDigest not available by org.apache.commons.codec.digest.DigestUtils SHA-256: fc0de412e726341a95ae30b8ede3dfbb502fa50f9532439e45ca86cdfa725489 by org.apache.commons.codec.digest.DigestUtils SHA-384: 75cd6f06373ff58d7f50d02a68116108d1c56761e401f20dda6a3fa863b477bb2ce2030d8c760bf9da228d4623262273 by org.apache.commons.codec.digest.DigestUtils SHA-512: 9e9b3e31616ac90d2ec9981a2ba05c2045af58af9c279aa5d9fc45248982fe4eafaeccc12270310c2819b5b8b7541f5d9ba884bfac1b3c3fdfe8c42adb283643 by org.apache.commons.codec.digest.DigestUtils SHA-应用 加入约定key，增加时间戳，排序 https://*?msg=f58d7f50d02a...16&timestamp=1590324555411 msg: 原始消息+key+时间戳 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-03-22 14:56:19 "},"pages/message-digest/MAC.html":{"url":"pages/message-digest/MAC.html","title":"MAC/HMAC","keywords":"","body":"消息摘要算法--MAC MAC(Message Authentication Code) HMAC(keyed-Hash Message Authentication Code),含有密钥的散列函数算法 融合MD、SHA MD系列：HmacMD2、HmacMD4、HmacMD5 SHA系列：HmacSHA1、HmacSHA224、HmacSHA256、HmacSHA384、HmacSHA512 应用：SecureCRT 算法 摘要长度 实现方法 HmacMD2 128 Bouncy Castle HmacMD4 128 Bouncy Castle HmacMD5 128 JDK HmacSHA1 160 JDK HmacSHA224 224 Bouncy Castle/JDK1.8 HmacSHA256 256 JDK HmacSHA384 384 JDK HmacSHA512 512 JDK 代码实现 package md.test; import javax.crypto.KeyGenerator; import javax.crypto.Mac; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; import org.apache.commons.codec.binary.Hex; import org.bouncycastle.crypto.Digest; import org.bouncycastle.crypto.digests.MD2Digest; import org.bouncycastle.crypto.digests.MD4Digest; import org.bouncycastle.crypto.digests.MD5Digest; import org.bouncycastle.crypto.digests.SHA1Digest; import org.bouncycastle.crypto.digests.SHA224Digest; import org.bouncycastle.crypto.digests.SHA256Digest; import org.bouncycastle.crypto.digests.SHA384Digest; import org.bouncycastle.crypto.digests.SHA512Digest; import org.bouncycastle.crypto.macs.HMac; import org.bouncycastle.crypto.params.KeyParameter; /** * keyed-Hash Message Authentication Code * @author Capricorncd * https://github.com/capricorncd */ public class TestMAC { private static final String HMAC_MD2 = \"HmacMD2\"; private static final String HMAC_MD4 = \"HmacMD4\"; private static final String HMAC_MD5 = \"HmacMD5\"; private static final String HMAC_SHA = \"HmacSHA1\"; private static final String HMAC_SHA_224 = \"HmacSHA224\"; private static final String HMAC_SHA_256 = \"HmacSHA256\"; private static final String HMAC_SHA_384 = \"HmacSHA384\"; private static final String HMAC_SHA_512 = \"HmacSHA512\"; public static void main(String[] args) { String src = \"keyed-Hash Message Authentication Code\"; // secret key, length = 10. String secretKey = \"aaaaaaaaaa\"; byte[] secretKeyBytes = org.bouncycastle.util.encoders.Hex.decode(secretKey); jdkHmac(src, HMAC_MD2, secretKeyBytes); jdkHmac(src, HMAC_MD4, secretKeyBytes); jdkHmac(src, HMAC_MD5, secretKeyBytes); println(); bcHmac(src, HMAC_MD2, new MD2Digest(), secretKeyBytes); bcHmac(src, HMAC_MD4, new MD4Digest(), secretKeyBytes); bcHmac(src, HMAC_MD5, new MD5Digest(), secretKeyBytes); println(); jdkHmac(src, HMAC_SHA, secretKeyBytes); jdkHmac(src, HMAC_SHA_224, secretKeyBytes); jdkHmac(src, HMAC_SHA_256, secretKeyBytes); jdkHmac(src, HMAC_SHA_384, secretKeyBytes); jdkHmac(src, HMAC_SHA_512, secretKeyBytes); println(); bcHmac(src, HMAC_SHA, new SHA1Digest(), secretKeyBytes); bcHmac(src, HMAC_SHA_224, new SHA224Digest(), secretKeyBytes); bcHmac(src, HMAC_SHA_256, new SHA256Digest(), secretKeyBytes); bcHmac(src, HMAC_SHA_384, new SHA384Digest(), secretKeyBytes); bcHmac(src, HMAC_SHA_512, new SHA512Digest(), secretKeyBytes); } /** * JDK HMAC * @param src source * @param algorithm * @param secretKeyBytes secret key bytes */ public static void jdkHmac(String src, String algorithm, byte[] secretKeyBytes) { String result = null; try { // restore secret key SecretKey restoreSecretKey = new SecretKeySpec(secretKeyBytes, algorithm); // instance MAC Mac mac = Mac.getInstance(restoreSecretKey.getAlgorithm()); // initial MAC mac.init(restoreSecretKey); // run byte[] resultBytes = mac.doFinal(src.getBytes()); result = Hex.encodeHexString(resultBytes); } catch (Exception e) { // e.printStackTrace(); result = e.getMessage(); } println(algorithm + \":\", result, \"by JDK\"); } /** * JDK HMAC * Automatically generate a secret key * @param src * @param algorithm */ public static void jdkHmac(String src, String algorithm) { try { // Automatically generate a secret key // initial KeyGenerator KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm); // create secret key SecretKey secretKey = keyGenerator.generateKey(); // get secret key byte[] secretKeyBytes = secretKey.getEncoded(); jdkHmac(src, algorithm, secretKeyBytes); } catch (Exception e) { // e.printStackTrace(); println(algorithm + \":\", e.getMessage(), \"by JDK\"); } } /** * bouncy castle HMAC * @param Digest * @param src source * @param algorithm * @param digest Digest * @param secretKeyBytes secret key bytes */ public static void bcHmac(String src, String algorithm, T digest, byte[] secretKeyBytes) { HMac hmac = new HMac(digest); // byte[] secretKeyBytes = org.bouncycastle.util.encoders.Hex.decode(\"aaaaaaaaaa\"); hmac.init(new KeyParameter(secretKeyBytes)); byte[] srcBytes = src.getBytes(); hmac.update(srcBytes, 0, srcBytes.length); byte[] resultBytes = new byte[hmac.getMacSize()]; hmac.doFinal(resultBytes, 0); String result = org.bouncycastle.util.encoders.Hex.toHexString(resultBytes); println(algorithm + \":\", result, \"by Bouncy Castle.\"); } /** * System.out.println * * @param args */ public static void println(Object... args) { for (Object o : args) { System.out.print(o + \" \"); } System.out.print(\"\\n\"); } } 运行结果： HmacMD2: Algorithm HmacMD2 not available by JDK HmacMD4: Algorithm HmacMD4 not available by JDK HmacMD5: 60abad09ecbc7f234c3066b76209d657 by JDK HmacMD2: cc2e396c39d58f3d6415eebfbf928744 by Bouncy Castle. HmacMD4: 199828516cc1f41baa9536e095e73483 by Bouncy Castle. HmacMD5: 60abad09ecbc7f234c3066b76209d657 by Bouncy Castle. HmacSHA1: ee77ed44862c69ff1b93d81a2cab40b714aeac39 by JDK HmacSHA224: 261be450a5b2f6e9dad0df89e14710c4a412ef89d4c9b8db76173c19 by JDK HmacSHA256: a6c974f0b1025844d8266e3ab8f0402c8467c5878dcd9982216c46b6fd90d067 by JDK HmacSHA384: 43a6703c1fa097ec80a1aec85b6f38eef34059c3b90dddce27c7fde3d5e7d716050a86aa09275b52c9378eb819774a32 by JDK HmacSHA512: da98cf562dfaa094624ee28464dd0c4e0ade2a07fc28bb5b5aadeb0cef59e43ec9a3eeef51cf33a6e30c1611e1dc912fac3f1108db15a72e390e47579e4dad23 by JDK HmacSHA1: ee77ed44862c69ff1b93d81a2cab40b714aeac39 by Bouncy Castle. HmacSHA224: 261be450a5b2f6e9dad0df89e14710c4a412ef89d4c9b8db76173c19 by Bouncy Castle. HmacSHA256: a6c974f0b1025844d8266e3ab8f0402c8467c5878dcd9982216c46b6fd90d067 by Bouncy Castle. HmacSHA384: 43a6703c1fa097ec80a1aec85b6f38eef34059c3b90dddce27c7fde3d5e7d716050a86aa09275b52c9378eb819774a32 by Bouncy Castle. HmacSHA512: da98cf562dfaa094624ee28464dd0c4e0ade2a07fc28bb5b5aadeb0cef59e43ec9a3eeef51cf33a6e30c1611e1dc912fac3f1108db15a72e390e47579e4dad23 by Bouncy Castle. MAC-应用 © 2019 Capricorncd all right reserved，powered by Gitbook该文件修订时间： 2020-03-22 16:17:03 "}}